<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://lisp.rocks/' rel='self' type='application/rss+xml'/>
<title>
(print &quot;Lisp Rocks&quot;)
</title>
<link>
http://lisp.rocks/
</link>
<description>
Lisp Rocks
</description>
<lastBuildDate>
Fri, 15 Dec 2023 07:33:50 +0800
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://lisp.rocks/posts-output/2023-12-15-停損與停利操作沒有那麼簡單/
</guid>
<link>
http://lisp.rocks/posts-output/2023-12-15-停損與停利操作沒有那麼簡單/
</link>
<title>
證券停損與停利操作，沒有你想的那麼簡單
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;停損停利：證券與期貨的差異&quot;&gt;&lt;/a&gt;停損停利：證券與期貨的差異&lt;/h2&gt;&lt;p&gt;在期貨市場中，券商通常會允許你掛單的同時，可以設定停損與停利價位&lt;/p&gt;&lt;p&gt;因為你有放保證金，所以無論是往停損與停利方向如何移動&lt;/p&gt;&lt;p&gt;券商大抵上都能幫你執行觸價單，不用擔心你是否有庫存、額度的問題&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;然而在證券市場中，你如果買進一張台積電，想要設定停損與停利&lt;/p&gt;&lt;p&gt;通常你只能在停損與停利其中一邊掛賣單，因為你只有庫存一張&lt;/p&gt;&lt;p&gt;而另一邊你得自己在客戶端跑洗價，或是借券、無券空，多空一張&lt;/p&gt;&lt;p&gt;事情就沒那麼容易了&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;情況&amp;#95;i：停利送出委託，停損本地洗價&quot;&gt;&lt;/a&gt;情況 I：停利送出委託，停損本地洗價&lt;/h2&gt;&lt;p&gt;若暫時不考慮有庫存或額度上的操作，我們可以看下圖：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12/20231215_1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;假設我們買進了一張台積電，一個合理的做法是對能限價的那一邊&lt;/p&gt;&lt;p&gt;掛出委託，也就是停利價位掛出一張 Sell Limit，庫存就用完了&lt;/p&gt;&lt;p&gt;然後在停損這一邊，本地洗價 Sell Stop&lt;/p&gt;&lt;p&gt;只要 #SL 和 #TP 有一邊成交，我們就把另一邊取消，類似二擇一操作&lt;/p&gt;&lt;p&gt;只是在這個情況中，我們 #TP 的委託是已經送到交易所&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12/20231215_2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;我們現在考慮價格碰到 #TP 價位並且成交 &lt;code&gt;&amp;#40;1&amp;#41;&lt;/code&gt; ，你會收到成交回報 &lt;code&gt;&amp;#40;2&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;這時候你就需要停止 #SL 的本地洗價並取消 &lt;code&gt;&amp;#40;3&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;並且由於成交回報會領先其他人收到成交通知 &lt;code&gt;&amp;#40;4&amp;#41;&lt;/code&gt; ，順序就會像：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12/20231215_3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;接著我們可以考慮價格是先觸碰到 #SL，由於本地在洗價 &lt;code&gt;&amp;#40;1&amp;#41;&lt;/code&gt; 被觸發&lt;/p&gt;&lt;p&gt;就會送 #SL 到交易所，然後在 &lt;code&gt;&amp;#40;2&amp;#41;&lt;/code&gt; 收到回報：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12/20231215_4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;這時候你想要把 #TP 刪單，但問題會比想像中複雜&lt;/p&gt;&lt;p&gt;我們先考慮理想情況，你送出刪單請求到交易所 &lt;code&gt;&amp;#40;3&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;接著收到交易所刪單成功的回報 &lt;code&gt;&amp;#40;4&amp;#41;&lt;/code&gt; ，多數情況是這樣沒錯：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12/20231215_5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;然而你可能遇到刪單失敗的情況，假如價格突然拉回&lt;/p&gt;&lt;p&gt;你的 #TP 由於在交易所，所以可能會在 &lt;code&gt;&amp;#40;2&amp;#41;&lt;/code&gt; ~ &lt;code&gt;&amp;#40;3&amp;#41;&lt;/code&gt; 中間的時候&lt;/p&gt;&lt;p&gt;被觸發成交 &lt;code&gt;&amp;#40;2.5&amp;#41;&lt;/code&gt; ，並且在你刪單送出到拿刪單結果的中間 &lt;code&gt;&amp;#40;3&amp;#41;&lt;/code&gt; ~ &lt;code&gt;&amp;#40;4&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;你會先收到成交通知 &lt;code&gt;&amp;#40;3.5&amp;#41;&lt;/code&gt; ，然後再收到刪單失敗的通知 &lt;code&gt;&amp;#40;4&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12/20231215_6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;像這樣買一張，卻賣到兩張的情況，要怎麼解決呢？&lt;/p&gt;&lt;p&gt;我們會在第二篇來討論，兩邊都放本地洗價的方式，並且這也是 OCO 二擇一單的基本原理&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Fri, 15 Dec 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-12-14-交易軟體中的雙時態資料設計與投影估計/
</guid>
<link>
http://lisp.rocks/posts-output/2023-12-14-交易軟體中的雙時態資料設計與投影估計/
</link>
<title>
交易軟體中的雙時態資料設計與定時單功能
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;交易軟體中的雙時態數據&amp;#95;(bi-temporal&amp;#95;data)&quot;&gt;&lt;/a&gt;交易軟體中的雙時態數據 (Bi-temporal data)&lt;/h2&gt;&lt;p&gt;雙時態數據&lt;sup&gt;&lt;a id=&quot;fnr.1&quot; class=&quot;footref&quot; href=&quot;#fn.1&quot; role=&quot;doc-backlink&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 是指一個事件具有兩個時間的數據，例如報價 (Quote)：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;生效時間 (Effective Time, ET): 報價具體指涉或生效的時間，例如 9:10:00 AM 的報價&lt;/li&gt;&lt;li&gt;應用時間 (Application Time, AT): 報價具體進到應用程式的時間，後一秒 9:10:01&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在報價中生效時間 100% 是落後應用時間，但是像是我們送出的委託：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;生效時間：委託具體送到券商或交易所，在券商與交易所上打上的時間，例如 9:15:10&lt;/li&gt;&lt;li&gt;應用時間：委託送出應用程式的時間，可能是 9:15:09 (早一秒)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以如果無關業務邏輯的話，雙時態數據的 ET 和 AT 可能有先有後。&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;p&gt;相比一般軟體設計，關聯的可能是自己的資料庫，在交易軟體中關聯的是第三方&lt;/p&gt;&lt;p&gt;也就是不需要擔心生效時間與應用時間衝突，永遠都是生效時間優先&lt;/p&gt;&lt;p&gt;從生效時間去預測應用時間，或是從應用時間去預測生效時間，就是所謂的 &lt;strong&gt;預測 (Projection)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;為什麼需要對&amp;#95;et&amp;#95;與&amp;#95;at&amp;#95;進行預測？&quot;&gt;&lt;/a&gt;為什麼需要對 ET 與 AT 進行預測？&lt;/h2&gt;&lt;p&gt;如果使用者有一個定時單，要在 9:15 送出一個台積電 2330 掛買一張&lt;/p&gt;&lt;p&gt;他是希望 ET 在 9:15，還是 AT 在 9:15？他是希望 9:15 送到交易所，還是 9:15 從電腦送出？&lt;/p&gt;&lt;p&gt;如果使用者要藉由 9:40 的台積電報價去生成另一個委託&lt;/p&gt;&lt;p&gt;他是希望以 ET 在 9:40 的報價來生成呢，還是 9:40 的應用時間&lt;/p&gt;&lt;p&gt;更複雜一點的狀況還包含，應用時間是在何時打上，可能是在報價進到電腦的時候打上&lt;/p&gt;&lt;p&gt;也有可能是在報價具體渲染到使用者畫面時打上，渲染前打上或渲染後打上&lt;/p&gt;&lt;p&gt;怎麼打都可以， &lt;strong&gt;關鍵是你就會需要去預測 ET 與 AT 的落差&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;並且根據使用者需求，去使用這個落差，例如提前操作、延後操作&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;以定時單為例&quot;&gt;&lt;/a&gt;以定時單為例&lt;/h2&gt;&lt;p&gt;使用者有一個單，他需要基於生效時間在 9:50 的報價，計算掛單量&lt;/p&gt;&lt;p&gt;然後定時在 10:00 要掛出，他希望盡可能生效時間接近 10:00 整掛出&lt;/p&gt;&lt;p&gt;而使用的報價也希望盡可能接近 9:50&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;由於我們要基於我們的大致預測去行為，就可能不那麼精準&lt;/p&gt;&lt;p&gt;這時候最關鍵的是，他對於提前的容忍度：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;1. &amp;#91; &amp;#93; 可以接受使用到 9:49:59 的報價嗎？
2. &amp;#91; &amp;#93; 可以接受掛單到 9:59:59 的情況嗎？&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果使用者不能接受提前，ET 與 AT 的落差就不能使用來調整操作時間&lt;/p&gt;&lt;p&gt;如果使用者可以接受，你就可以盡量考量 ET/AT 的落差，讓 ET 落在使用者期待的時間&lt;/p&gt;&lt;p&gt;當然，這裡面可能就有很多規則，甚至啟動應用程式時還得試算 ET/AT 與評估網路情況&lt;/p&gt;&lt;p&gt;但大致的原則就是這樣，雙時態數據在例如開盤、尾盤與一些時間事件的交易處理上很有幫助&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;延伸討論：et&amp;#95;與&amp;#95;at&amp;#95;只會有一個嗎？&quot;&gt;&lt;/a&gt;延伸討論：ET 與 AT 只會有一個嗎？&lt;/h2&gt;&lt;p&gt;雙時態數據可能是最基本、最有表達力的方式，但有時候你可能需要更多時態描述事件&lt;/p&gt;&lt;p&gt;例如 ET 可能是個範圍，你的操作具體生效開始到生效結束有一個範圍&lt;/p&gt;&lt;p&gt;而 AT 也可能是個範圍，你的操作具體在應用程式中開始，到應用程式接收／發送完畢&lt;/p&gt;&lt;p&gt;完全可以根據你的需求延伸去做設計，以及根據 API 呼叫可能有的限制，去調整你的預測&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h1&gt;&lt;a name=&quot;footnotes&quot;&gt;&lt;/a&gt;Footnotes&lt;/h1&gt;&lt;p&gt;&lt;sup&gt;&lt;a id=&quot;fn.1&quot; href=&quot;#fnr.1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 雙時態數據在資料庫處理中，屬於事件溯源的範疇&lt;br/&gt;見：&lt;a href=&quot;https://www.planetgeek.ch/2023/12/04/our-experience-with-bi-temporal-event-sourcing/&quot;&gt;https://www.planetgeek.ch/2023/12/04/our-experience-with-bi-temporal-event-sourcing/&lt;/a&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 14 Dec 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-12-12-使用-SciPy-solve_ivp-建立投資組合調倉策略/
</guid>
<link>
http://lisp.rocks/posts-output/2023-12-12-使用-SciPy-solve_ivp-建立投資組合調倉策略/
</link>
<title>
使用 SciPy 的 solve_ivp 建立投資組合調倉策略
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;避險&amp;#95;=&amp;#95;對時間的微分方程&quot;&gt;&lt;/a&gt;避險 = 對時間的微分方程&lt;/h2&gt;&lt;p&gt;如果我們假設市場存在一個風險特徵 &lt;code&gt;V&amp;#40;t&amp;#41;&lt;/code&gt; ，而我們避險策略是 &lt;code&gt;E&amp;#40;t&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;當避險目標和風險特徵吻合， &lt;code&gt;V&amp;#40;t&amp;#95;k&amp;#41; = E&amp;#40;t&amp;#95;k&amp;#41;&lt;/code&gt; ，我們在 &lt;code&gt;t=t&amp;#95;k&lt;/code&gt; 時點的投資組合不需要調整&lt;/p&gt;&lt;p&gt;如果當風險特徵大於避險策略 &lt;code&gt;V&amp;#40;t&amp;#95;k&amp;#41; &amp;gt; E&amp;#40;t&amp;#95;k&amp;#41;&lt;/code&gt; ，需要提高我們的避險幅度 &lt;code&gt;E&amp;#40;t&amp;#95;k+1&amp;#41; &amp;gt; E&amp;#40;t&amp;#95;k&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;當風險特徵小於避險策略 &lt;code&gt;V&amp;#40;t&amp;#95;k&amp;#41; &amp;lt; E&amp;#40;t&amp;#95;k&amp;#41;&lt;/code&gt; ，需要降低我們的避險幅度 &lt;code&gt;E&amp;#40;t&amp;#95;k+1&amp;#41; &amp;lt; E&amp;#40;t&amp;#95;k&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;這樣的概念，就能轉化成一個 ODE： &lt;code&gt;dE&amp;#40;t&amp;#41;/dt = f&amp;#40;t&amp;#41; &amp;#42; &amp;#40; V&amp;#40;t&amp;#41; - E&amp;#40;t&amp;#41; &amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;其中的 &lt;code&gt;f&amp;#40;t&amp;#41;&lt;/code&gt; 就是應對這個風險特徵與避險目標落差幅度所需的操作&lt;/p&gt;&lt;p&gt;我們就能把任何避險調倉操作，轉換成一個 ODE 問題來求解&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;scipy&amp;#95;的&amp;#95;&lt;code&gt;solve&amp;#95;ivp&lt;/code&gt;&quot;&gt;&lt;/a&gt;SciPy 的 &lt;code&gt;solve&amp;#95;ivp&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;solve&amp;#95;ivp&lt;/code&gt; 是 SciPy 的一個函數，可以基於給定的初始值對 ODE 求解&lt;/p&gt;&lt;p&gt;也就是將 ODE 看成是一個初始值問題&lt;sup&gt;&lt;a id=&quot;fnr.1&quot; class=&quot;footref&quot; href=&quot;#fn.1&quot; role=&quot;doc-backlink&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; (Initial Value Problem, IVP) 進行求解 (Solve)&lt;/p&gt;&lt;p&gt;我們可以對 &lt;code&gt;solve&amp;#95;ivp&lt;/code&gt; 指定求解的精度，透過使用 &lt;code&gt;numpy&lt;/code&gt; 指定涉及變量的網格採樣點&lt;/p&gt;&lt;p&gt;並且也能針對給定位置檢測零值、極值發生的事件，一個簡單的初始值問題如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;from scipy.integrate import solve&amp;#95;ivp
import numpy as np
import matplotlib.pyplot as plt

# 定義一個 ODE: dy/dt = -2y, 其中初始值條件為 y&amp;#40;0&amp;#41; = 1
y0 = &amp;#91;1&amp;#93;
def odefn&amp;#40;t, y&amp;#41;:
    return -2 &amp;#42; y

# 定義時間的採樣點範圍，並在該範圍採樣
t&amp;#95;span = &amp;#40;0, 5&amp;#41;
t&amp;#95;eval = np.linspace&amp;#40;0, 5, 100&amp;#41;
sol = solve&amp;#95;ivp&amp;#40;odefn, t&amp;#95;span, y0, t&amp;#95;eval=t&amp;#95;eval&amp;#41;

# 各時間點的對應的解
print&amp;#40;sol.t&amp;#41;
print&amp;#40;sol.y&amp;#41;

# 繪圖
plt.plot&amp;#40;sol.t, sol.y&amp;#91;0, :&amp;#93;, label='y&amp;#40;t&amp;#41;'&amp;#41;
plt.xlabel&amp;#40;'Time t'&amp;#41;
plt.ylabel&amp;#40;'y&amp;#40;t&amp;#41;'&amp;#41;
plt.title&amp;#40;'Solution of the ODE dy/dt = -2y'&amp;#41;
plt.legend&amp;#40;&amp;#41;
plt.show&amp;#40;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;求解調倉策略&quot;&gt;&lt;/a&gt;求解調倉策略&lt;/h2&gt;&lt;p&gt;如果考慮調倉操作為一個固定速度 &lt;code&gt;k&lt;/code&gt; ，風險與避險目標差距越大，就要越積極做避險：&lt;/p&gt;&lt;p&gt;&lt;code&gt;dE&amp;#40;t&amp;#41;/dt = k &amp;#42; &amp;#40; V&amp;#40;t&amp;#41; - E&amp;#40;t&amp;#41; &amp;#41;, k &amp;gt; 0&lt;/code&gt;&lt;/p&gt;&lt;p&gt;接著我們就能對風險建模，常用的方法可能是均值回歸的時間序列模型&lt;/p&gt;&lt;p&gt;在此我們以 &lt;code&gt;sin&lt;/code&gt; 來示範：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import numpy as np
from scipy.integrate import solve&amp;#95;ivp
import matplotlib.pyplot as plt

def PortfolioDynamics&amp;#40;t, E, k, V&amp;#95;func&amp;#41;:
    return k &amp;#42; &amp;#40;V&amp;#95;func&amp;#40;t&amp;#41; - E&amp;#41;

def Risk&amp;#40;t&amp;#41;:
    # 這裡假設風險變化是時間的正弦函數
    return 2 + np.sin&amp;#40;t / 5&amp;#41;

# 初始值
k = 0.1
E0 = &amp;#91;0.4&amp;#93;

# 求解 ODE
t&amp;#95;span = &amp;#40;0, 100&amp;#41;  # 給定時間範圍
t&amp;#95;eval = np.linspace&amp;#40;t&amp;#95;span&amp;#91;0&amp;#93;, t&amp;#95;span&amp;#91;1&amp;#93;, 300&amp;#41;
sol = solve&amp;#95;ivp&amp;#40;PortfolioDynamics, t&amp;#95;span, E0, args=&amp;#40;k, Risk&amp;#41;, t&amp;#95;eval=t&amp;#95;eval&amp;#41;

# 繪圖
plt.plot&amp;#40;sol.t, sol.y&amp;#91;0&amp;#93;, label='Hedge'&amp;#41;
plt.plot&amp;#40;sol.t, &amp;#91;Risk&amp;#40;t&amp;#41; for t in sol.t&amp;#93;, label='Risk'&amp;#41;
plt.xlabel&amp;#40;'Time'&amp;#41;
plt.ylabel&amp;#40;'Hedge / Risk'&amp;#41;
plt.legend&amp;#40;&amp;#41;
plt.show&amp;#40;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;從這張圖可以看到：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;初始值對初始值問題 IVP 的影響，起始避險目標不足，就得花更大的功夫追上風險特徵&lt;/li&gt;&lt;li&gt;由於調倉是基於風險與避險目標的差值做決策，始終落後於風險變化，有週期錯位的感覺&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;反之亦然：從風險和交易結果，反過來對行為建模&quot;&gt;&lt;/a&gt;反之亦然：從風險和交易結果，反過來對行為建模&lt;/h2&gt;&lt;p&gt;這個 ODE 求解本身並沒有太多厲害之處，但是如果你現在有兩條線，就能反推你的交易行為建模&lt;/p&gt;&lt;p&gt;將你的交易行為還原成一種 ODE，可能不只一階，有二階、三階甚至高階&lt;/p&gt;&lt;p&gt;最常見的就是市場波動度，與你的交易策略在不同波動度底下的交易行為，反過來建模&lt;/p&gt;&lt;p&gt;建模起來就能推測你後續的交易行為，這也可以作為一種對交易結果逆向工程破解交易策略的方法&lt;/p&gt;&lt;p&gt;再一個反之，如果破解不了，就代表沒有蘊含清晰的時變動力系統 (Time-varying dynamics)&lt;/p&gt;&lt;p&gt;可能是基於事件、其他因素做交易，而非簡易的計算邏輯，可能很多交易來自特殊決策&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h1&gt;&lt;a name=&quot;footnotes&quot;&gt;&lt;/a&gt;Footnotes&lt;/h1&gt;&lt;p&gt;&lt;sup&gt;&lt;a id=&quot;fn.1&quot; href=&quot;#fnr.1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 初始值問題是微分方程的一種問題，請見:&lt;br/&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E5%88%9D%E5%80%BC%E5%95%8F%E9%A1%8C&quot;&gt;https://zh.wikipedia.org/zh-tw/%E5%88%9D%E5%80%BC%E5%95%8F%E9%A1%8C&lt;/a&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 12 Dec 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-12-11-使用-Dictizable-在進程間傳遞-Struct-來下單/
</guid>
<link>
http://lisp.rocks/posts-output/2023-12-11-使用-Dictizable-在進程間傳遞-Struct-來下單/
</link>
<title>
使用 Dictizable 在進程間傳遞 Struct 來下單
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;券商&amp;#95;api&amp;#95;的&amp;#95;struct&quot;&gt;&lt;/a&gt;券商 API 的 Struct&lt;/h2&gt;&lt;p&gt;有些券商 Python API 是透過 C# 介接過來的，所以下單往往得給他一個 struct，類似 Python 字典&lt;/p&gt;&lt;p&gt;不只下單，其實在取得一些報價資訊、查詢帳務等，都可能需要給一個 struct&lt;/p&gt;&lt;p&gt;如果 API 的 lib 元件與下單操作是在同一個進程，你可以很輕鬆的透過券商 API 建立 struct&lt;/p&gt;&lt;p&gt;並把 struct 中的欄位填滿並送出，以此來下單&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;跨進程物件共享：共享變數、pipe&amp;#95;通信與&amp;#95;queue&quot;&gt;&lt;/a&gt;跨進程物件共享：共享變數、PIPE 通信與 Queue&lt;/h2&gt;&lt;p&gt;通常在跨進程間，保守作法是不考慮共享變數，避免同個進程同時使用到相同變數&lt;/p&gt;&lt;p&gt;一個安全做法是透過 PIPE 通信與 Queue，然而這就只允許你傳遞基本類別，例如字典和文字數字&lt;sup&gt;&lt;a id=&quot;fnr.1&quot; class=&quot;footref&quot; href=&quot;#fn.1&quot; role=&quot;doc-backlink&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;那為了在整個進程內都正確的使用 Struct，我們可以針對券商的每個 struct 建立一個字典&lt;/p&gt;&lt;p&gt;透過字典轉 struct 與 struct 轉字典，來傳遞物件並下單&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;dictizable：dict&amp;#95;的可聽寫模式的封裝&quot;&gt;&lt;/a&gt;Dictizable：Dict 的可聽寫模式的封裝&lt;/h2&gt;&lt;p&gt;如果只是單純用字典，很容易被亂塞東西，如果用類過深的封裝，又難以轉換為字典在進程間傳遞&lt;/p&gt;&lt;p&gt;所以一個簡單的方式就是建立一個簡單的可讀寫字典 (Dictizable) 的類來包裝&lt;sup&gt;&lt;a id=&quot;fnr.2&quot; class=&quot;footref&quot; href=&quot;#fn.2&quot; role=&quot;doc-backlink&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Dictizable 意指 dict- (字典) 與 dictizable (可讀寫) 的含意&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;也就是我們個別拆分寫入 (Serializable) 與讀取 (Deserializable) 兩個要求，並組合成一個介面：&lt;/p&gt;&lt;pre&gt;&lt;code&gt; from &amp;#95;&amp;#95;future&amp;#95;&amp;#95; import annotations
 from abc import ABC, abstractmethod

 class DictSerializable&amp;#40;ABC&amp;#41;:
   @abstractmethod
   def to&amp;#95;dict&amp;#40;self&amp;#41; -&amp;gt; dict:
       &amp;quot;&amp;quot;&amp;quot;
       Takes &amp;#42;this&amp;#42; instance of the implemented method's class and returns its representation as a dictionary.
       &amp;quot;&amp;quot;&amp;quot;

 class DictDeserializable&amp;#40;ABC&amp;#41;:
     @staticmethod
     @abstractmethod
     def from&amp;#95;dict&amp;#40;d: dict&amp;#41; -&amp;gt; DictDeserializable:
         &amp;quot;&amp;quot;&amp;quot;
         Takes a dict and turns it into an instance of &amp;#42;this&amp;#42; class.
         &amp;quot;&amp;quot;&amp;quot;
class Dictizable&amp;#40;DictSerializable, DictDeserializable&amp;#41;:
    pass&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;這樣的好處是，在進程間操作可以是單向的，對於下單介面視窗的進程&lt;/p&gt;&lt;p&gt;可以使用 DictSerializable 寫入下單資訊&lt;/p&gt;&lt;p&gt;在執行 API 操作的進程收到字典後，立刻封裝到 DictDeserializable 的類並唯讀使用&lt;/p&gt;&lt;p&gt;確保該進程不能修改視窗傳遞來的物件&lt;/p&gt;&lt;p&gt;反之，在視窗介面應該以唯讀的方式讀取報價資訊，而個別物件寫入與讀取的方法都要寫好&lt;/p&gt;&lt;p&gt;這個方式原意是要處理資料庫與 Python 之間的問題，但也很適合延伸到交易軟體設計中思考&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h1&gt;&lt;a name=&quot;footnotes&quot;&gt;&lt;/a&gt;Footnotes&lt;/h1&gt;&lt;p&gt;&lt;sup&gt;&lt;a id=&quot;fn.1&quot; href=&quot;#fnr.1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; multiprocessing 基本上就是複製一份 PIPE 處理，所以 Class 都不能傳遞。詳見：&lt;br/&gt;&lt;a href=&quot;https://docs.python.org/3/library/multiprocessing.html&quot;&gt;https://docs.python.org/3/library/multiprocessing.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;sup&gt;&lt;a id=&quot;fn.2&quot; href=&quot;#fnr.2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; Dictizable 的想法與實作來自於 Joey Greco:&lt;br/&gt;&lt;a href=&quot;https://joeyagreco.medium.com/the-dictizable-pattern-in-python-1008f37efde7&quot;&gt;https://joeyagreco.medium.com/the-dictizable-pattern-in-python-1008f37efde7&lt;/a&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 11 Dec 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-12-10-在-return-後執行來加快子線程的運作，以商品檔資訊為例/
</guid>
<link>
http://lisp.rocks/posts-output/2023-12-10-在-return-後執行來加快子線程的運作，以商品檔資訊為例/
</link>
<title>
處理商品檔資訊並在 return 後執行來加快子線程的運作
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;商品檔的資訊&quot;&gt;&lt;/a&gt;商品檔的資訊&lt;/h2&gt;&lt;p&gt;通常券商 API 提供商品檔資訊會很豐富，但需要一直處理大量商品檔資料&lt;/p&gt;&lt;p&gt;而通常我們需要商品檔基本資訊，例如商品代碼與商品名稱，然後去處理其他事情&lt;/p&gt;&lt;p&gt;這時候就可以讓處理商品檔的線程，先回傳商品檔的基本資訊，再繼續添加商品檔資訊到商品檔中&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;使用&amp;#95;&lt;code&gt;try/finally&lt;/code&gt;&amp;#95;提早&amp;#95;return&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;try/finally&lt;/code&gt; 提早 return&lt;/h2&gt;&lt;p&gt;為了達成這個目標，就可以利用 &lt;code&gt;try/finally&lt;/code&gt; 來實現提早回傳並繼續運算&lt;/p&gt;&lt;p&gt;而提早回傳可能就能觸發其他子線程開始工作，就能加快處理速度：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import threading
import time

def addData&amp;#40;newData&amp;#41;:
    try:
        dataDict = {}
        print&amp;#40;f'原本的字典: {dataDict}'&amp;#41;
        dataDict.update&amp;#40;newData&amp;#41;
        return dataDict
    finally:
        def fn&amp;#40;dataDict&amp;#41;:
            time.sleep&amp;#40;1&amp;#41;
            dataDict.update&amp;#40;{'漲停': 700}&amp;#41;
            print&amp;#40;f'回傳後繼續處理 ... {dataDict}'&amp;#41;
            time.sleep&amp;#40;1&amp;#41;
            dataDict.update&amp;#40;{'跌停': 600}&amp;#41;
            print&amp;#40;f'回傳後繼續處理 ... {dataDict}'&amp;#41;
        threading.Thread&amp;#40;target=fn, args=&amp;#40;dataDict,&amp;#41;&amp;#41;.start&amp;#40;&amp;#41;

def sendOrder&amp;#40;data&amp;#41;:
    print&amp;#40;f&amp;quot;先取得商品代碼，立即下單 '{data&amp;#91;'code'&amp;#93;}'&amp;quot;&amp;#41;

data = addData&amp;#40;{'code': 2330}&amp;#41;
sendOrder&amp;#40;data&amp;#41;

# 原本的字典: {}
# 先取得商品代碼，下單 '2330'
# 回傳後繼續處理 ... {'code': 2330, 'name': '台積電', '漲停': 700}
# 回傳後繼續處理 ... {'code': 2330, 'name': '台積電', '漲停': 700, '跌停': 600}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這就是一個範例，先將商品檔資訊回傳，其中有商品代碼就能執行其他工作&lt;/p&gt;&lt;p&gt;再慢慢把商品檔資訊補進去字典中，在另一個線程也能享有這些新的資訊更新&lt;/p&gt;&lt;p&gt;實際上可能不會在 &lt;code&gt;finally&lt;/code&gt; threading start，而是會把 &lt;code&gt;fn&lt;/code&gt; 添加到 Pool 中&lt;/p&gt;&lt;p&gt;當然， &lt;code&gt;fn&lt;/code&gt; 可以寫在外面，或在 &lt;code&gt;sendOrder&lt;/code&gt; 後執行&lt;/p&gt;&lt;p&gt;但是這樣寫的好處在於， &lt;code&gt;finally&lt;/code&gt; 要做的事情可以寫在 &lt;code&gt;addData&lt;/code&gt; 中&lt;/p&gt;&lt;p&gt;而不會受到 &lt;code&gt;addData&lt;/code&gt; 以外的東西影響，又能在回傳後繼續執行，甚至成為監聽器&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sun, 10 Dec 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-12-09-使用-frozenset-處理委託書號與序號對應問題/
</guid>
<link>
http://lisp.rocks/posts-output/2023-12-09-使用-frozenset-處理委託書號與序號對應問題/
</link>
<title>
使用 frozenset 處理委託書號與序號對應問題
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;委託書號與序號&quot;&gt;&lt;/a&gt;委託書號與序號&lt;/h2&gt;&lt;p&gt;只要交易委託有送到交易所，你就會收到委託書編號 (Book Number, bookNo)，簡稱 &lt;strong&gt;委託書號&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在台灣委託書號原則上都是 5 碼英數字混合，不分大小寫 &lt;sup&gt;&lt;a id=&quot;fnr.1&quot; class=&quot;footref&quot; href=&quot;#fn.1&quot; role=&quot;doc-backlink&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12-09/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;而預約單或智慧單&lt;sup&gt;&lt;a id=&quot;fnr.2&quot; class=&quot;footref&quot; href=&quot;#fn.2&quot; role=&quot;doc-backlink&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;，可能還未送到交易所，但券商已經收到&lt;/p&gt;&lt;p&gt;就會自己編委託書序號（Sequence number, seqNo)，簡稱 &lt;strong&gt;委託序號&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;每家券商編法不同，一種方式是編 13 碼純數字&lt;/p&gt;&lt;p&gt;所以一個委託，他就可能存在多個可以當作委託索引 (index) 的東西：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;在還沒有抵達交易所前，在券商那預約中，僅有委託序號&lt;/li&gt;&lt;li&gt;交易所開始接收券商委託，會有委託序號和委託書號&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;對於這種多重且不定的鍵值的情況，可以使用 Python &lt;code&gt;frozenset&lt;/code&gt; 當字典的 key&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;&lt;code&gt;frozenset&lt;/code&gt;&amp;#95;的用法&quot;&gt;&lt;/a&gt;&lt;code&gt;frozenset&lt;/code&gt; 的用法&lt;/h2&gt;&lt;p&gt;先來複習一下 &lt;code&gt;frozenset&lt;/code&gt; 有兩個主要功能：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;不可更改且不會重複的集合&lt;/li&gt;&lt;li&gt;可做為字典的 key&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;第一點衍生的使用情境就是，在跨進程間共享不可重複變數。&lt;/p&gt;&lt;p&gt;第二點的使用情境比較多，基本上可以分成兩類：&lt;/p&gt;&lt;p&gt;a. 時間面, 紀錄資料的版本或更新&lt;/p&gt;&lt;p&gt;b. 空間面, 表示資料的複數特徵&lt;/p&gt;&lt;p&gt;例如你原本有一個基本資料表單，並且紀錄每個版本使用者完成並審核通過的欄位&lt;/p&gt;&lt;p&gt;透過 &lt;code&gt;frozenset&lt;/code&gt; 可以有另一種寫法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;data = &amp;#91;{ version: 1, verified: set&amp;#40;&amp;#91;&amp;quot;name&amp;quot;&amp;#93;&amp;#41; },                # 新增名字, 驗證通過
        { version: 2, verified: set&amp;#40;&amp;#91;&amp;quot;name&amp;quot; &amp;quot;phonenumber&amp;quot;&amp;#93;&amp;#41; },  # 新增手機號碼, 驗證通過
        { version: 3, verified: set&amp;#40;&amp;#91;&amp;quot;name&amp;quot; &amp;quot;address&amp;quot;&amp;#93;&amp;#41;},       # 修改手機號碼, 沒有驗證 ; 新增地址, 驗證通過

# frozenset
data = {
    frozenset&amp;#40;&amp;#91;&amp;quot;name&amp;quot;&amp;#93;&amp;#41;: {version: 1},
    frozenset&amp;#40;&amp;#91;&amp;quot;name&amp;quot;, &amp;quot;phonenumber&amp;quot;&amp;#93;&amp;#41;: {version: 2},
    frozenset&amp;#40;&amp;#91;&amp;quot;name&amp;quot;, &amp;quot;address&amp;quot;&amp;#93;&amp;#41;: {version: 3}
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 &lt;code&gt;frozenset&lt;/code&gt; 作為字典 key，通常代表狀態比較確定，或是有固定有限的複數特徵&lt;/p&gt;&lt;p&gt;並且作為複雜的 key, 通常對應的東西應該要簡單單一，否則複雜對應複雜，就失去意義&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;委託書號與序號對應問題&quot;&gt;&lt;/a&gt;委託書號與序號對應問題&lt;/h2&gt;&lt;p&gt;所以我們就能使用 &lt;code&gt;frozenset&lt;/code&gt; 作為字典 key, 例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;replyDict = {
    frozenset&amp;#40;&amp;#91;&amp;quot;V01M0&amp;quot;, &amp;quot;12345678&amp;quot;&amp;#93;&amp;#41;: reply1,
    frozenset&amp;#40;&amp;#91;&amp;quot;23456789&amp;quot;&amp;#93;&amp;#41;: reply2
}

# 查找非常簡單:
seqNo = &amp;quot;23456789&amp;quot;
for key, value in replyDict.items&amp;#40;&amp;#41;:
  if seqNo in key:
      reply = value
      break&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查找就變得非常簡單，委託書號和序號都會找到同一個 Reply&lt;/p&gt;&lt;p&gt;而如果一旦送到交易所有委託序號了，就能：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# 得到委託書號了，新增 key 也非常方便
seqNo = &amp;quot;23456789&amp;quot;
bookNo = &amp;quot;ABC12&amp;quot;
for key, value in replyDict.items&amp;#40;&amp;#41;:
  if seqNo in key:
      replyDict&amp;#91;frozenset&amp;#40;key | {bookNo}&amp;#41;&amp;#93; = value
      del replyDict&amp;#91;key&amp;#93;
      break&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就算在多線程, 多進程中, 用原始 &lt;code&gt;seqNo&lt;/code&gt; 找也會找到對的, 所以不用擔心&lt;/p&gt;&lt;p&gt;透過這個方式，就可以無論委託書號或序號，都能指向同一個資料，就不需要判斷了&lt;/p&gt;&lt;p&gt;甚至改單、刪單要互相指向同一個 Order，也都可以很容易做&lt;/p&gt;&lt;h1&gt;&lt;a name=&quot;footnotes&quot;&gt;&lt;/a&gt;Footnotes&lt;/h1&gt;&lt;p&gt;&lt;sup&gt;&lt;a id=&quot;fn.1&quot; href=&quot;#fnr.1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 委託書編號原則 (公文) &lt;a href=&quot;https://www.tpex.org.tw/storage/eb&lt;i&gt;data/9905/0500057.htm&quot;&gt;https://www.tpex.org.tw/storage/eb&lt;/i&gt;data/9905/0500057.htm&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;sup&gt;&lt;a id=&quot;fn.2&quot; href=&quot;#fnr.2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 在台灣洗價、觸價單、多重IOC單是券商服務，概括是智慧單&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 09 Dec 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-12-07-使用-time-perf-counter-ns-處理券商-API-時間精度不足的問題/
</guid>
<link>
http://lisp.rocks/posts-output/2023-12-07-使用-time-perf-counter-ns-處理券商-API-時間精度不足的問題/
</link>
<title>
使用 perf_counter 處理券商 API 時間精度不足的問題
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;券商&amp;#95;api&amp;#95;回傳結果時間精度不足問題&quot;&gt;&lt;/a&gt;券商 API 回傳結果時間精度不足問題&lt;/h2&gt;&lt;p&gt;對於多數券商 API 而言，無論你取得報價、回報等資料，券商 API 通常只會保證：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;會依序拿到資料&lt;/li&gt;&lt;li&gt;必要的資料會包含時間（例如委託成功時間）&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;通常為了依序拿到資料，券商 API 會希望你盡快離開函數&lt;/p&gt;&lt;p&gt;例如報價可能是從 &lt;code&gt;OnNewTick&amp;#40;tick&amp;#41;&lt;/code&gt; 這樣回來，你一開始將函數註冊給 API&lt;/p&gt;&lt;p&gt;一旦有新的 Tick 你的函數就會被調用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;def OnNewTick&amp;#40;tick&amp;#41;:
    print&amp;#40;f&amp;quot;新的 Tick: {tick}&amp;quot;&amp;#41;

api.register&amp;#40;&amp;quot;OnNewTick&amp;quot;, OnNewTick&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而只要你的 &lt;code&gt;OnNewTick&amp;#40;tick&amp;#41;&lt;/code&gt; 還沒有處理完，通常就會阻塞到後續的 tick&lt;/p&gt;&lt;p&gt;甚至影響其他註冊函數的觸發（這將導致大量問題，未來持續探討）&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12-07/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;為了盡快地離開事件函數，通常就會用各種非同步、併發的方式處理&lt;/p&gt;&lt;p&gt;但是這就會導致每個事件觸發雖然在 API 給你的時候是依序的&lt;/p&gt;&lt;p&gt;但是為了不阻塞，你的非同步處理過程就可能導致結果亂序。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12-07/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;而資料本身的若有附帶時間，通常也不會足夠精細，例如只到毫秒等級&lt;/p&gt;&lt;p&gt;你可能會得到【一大批的資料，但是每一筆的毫秒時間是相同的】。&lt;/p&gt;&lt;p&gt;如果這時候你又非同步去處理，就需要特別紀錄時間（或是另一種方式，自己打流水號）&lt;/p&gt;&lt;p&gt;再根據流水號對應處理，例如等待、累積批次 … 等。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/2023-12-07/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;使用&amp;#95;&lt;code&gt;time.perf&amp;#95;counter&amp;#95;ns&amp;#40;&amp;#41;&lt;/code&gt;&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;time.perf&amp;#95;counter&amp;#95;ns&amp;#40;&amp;#41;&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;就算再怎麼非同步，註冊函數被調用的順序是可以保證的&lt;/p&gt;&lt;p&gt;只要有順序，我們就能使用： &lt;code&gt;time.perf&amp;#95;counter&amp;#95;ns&amp;#40;&amp;#41;&lt;/code&gt; ，因為：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;不受系統時間影響&lt;/li&gt;&lt;li&gt;單調遞增&lt;/li&gt;&lt;li&gt;精度到奈秒&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;， 但請注意，他不是時間，每次執行起始數值都不同：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import time

def OnNewTick&amp;#40;tick&amp;#41;:
    tid = time.perf&amp;#95;counter&amp;#95;ns&amp;#40;&amp;#41;
    print&amp;#40;f&amp;quot;&amp;#40;No.{tid}&amp;#41; 新的 Tick: {tick}&amp;quot;&amp;#41;

# 假設 api 依序調用
OnNewTick&amp;#40;{'bid': 611, 'ask': 766}&amp;#41;
OnNewTick&amp;#40;{'bid': 627, 'ask': 708}&amp;#41;
OnNewTick&amp;#40;{'bid': 646, 'ask': 781}&amp;#41;
OnNewTick&amp;#40;{'bid': 607, 'ask': 730}&amp;#41;
OnNewTick&amp;#40;{'bid': 653, 'ask': 770}&amp;#41;
OnNewTick&amp;#40;{'bid': 638, 'ask': 784}&amp;#41;
OnNewTick&amp;#40;{'bid': 603, 'ask': 760}&amp;#41;

# &amp;#40;No.21820900&amp;#41; 新的 Tick: {'bid': 611, 'ask': 766}
# &amp;#40;No.21846100&amp;#41; 新的 Tick: {'bid': 627, 'ask': 708}
# &amp;#40;No.21850600&amp;#41; 新的 Tick: {'bid': 646, 'ask': 781}
# &amp;#40;No.21853900&amp;#41; 新的 Tick: {'bid': 607, 'ask': 730}
# &amp;#40;No.21857200&amp;#41; 新的 Tick: {'bid': 653, 'ask': 770}
# &amp;#40;No.21860200&amp;#41; 新的 Tick: {'bid': 638, 'ask': 784}
# &amp;#40;No.21863400&amp;#41; 新的 Tick: {'bid': 603, 'ask': 760}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在絕大多數情況下， &lt;code&gt;time.time&amp;#40;&amp;#41;&lt;/code&gt; 是可以的，但是若：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;遇到日光節約時間，或各種時間調整情況&lt;/li&gt;&lt;li&gt;或是程式在運行中物理移動導致系統時間自動校正&lt;/li&gt;&lt;li&gt;可能會導致 &lt;code&gt;time.time&amp;#40;&amp;#41;&lt;/code&gt; 不保證遞增，並且沒有錯誤可以捕捉&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以可以考慮：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;time.monotonic&amp;#40;&amp;#41;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;time.perf&amp;#95;counter&amp;#40;&amp;#41;&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;如果需要更精細的粒度，那就是用 &lt;code&gt;perf&amp;#95;counter&lt;/code&gt;&lt;/p&gt;&lt;p&gt;又由於我們主要可能是用於比大小，正確依序處理券商資料&lt;/p&gt;&lt;p&gt;因此 &lt;code&gt;int&lt;/code&gt; 可能更適合比較（浮點數是使用近似比较），那就用 &lt;code&gt;perf&amp;#95;counter&amp;#95;ns&lt;/code&gt;&lt;/p&gt;&lt;p&gt;你可能會想要自己打流水號，但這就可能牽涉到跨子進程是否能安全共享流水號狀態&lt;/p&gt;&lt;p&gt;流水號遞增過程是否嚴格遞增。&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 07 Dec 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-12-04-Python-處理效能問題中使用-while-else/
</guid>
<link>
http://lisp.rocks/posts-output/2023-12-04-Python-處理效能問題中使用-while-else/
</link>
<title>
Python 處理效能問題中使用 while/else
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;使用情景&quot;&gt;&lt;/a&gt;使用情景&lt;/h2&gt;&lt;p&gt;由於經常得處理 Python 效能的追求與改善，少不了的就是：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;起 Thread 跑 While loop 監聽&lt;/li&gt;&lt;li&gt;起一堆 While loop 對同一個 Queue &lt;code&gt;get&amp;#40;&amp;#41;&lt;/code&gt; ，來大量阻塞和消化不斷湧入到 Queue 的資料&lt;/li&gt;&lt;li&gt;&lt;code&gt;while xxxx.isAlive&amp;#40;&amp;#41;&lt;/code&gt; 卡檔案或第三方 Context/Client 處理 I/O 問題&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;無論是哪個，都免不了 &lt;code&gt;While &amp;lt;condition&amp;gt;:&lt;/code&gt; 中的 condition 可能會出錯，通常就得用 &lt;code&gt;if/else&lt;/code&gt; 打補丁&lt;/p&gt;&lt;p&gt;但是 Python 有一個很獨門的語法，在其他語言中少見的就是 &lt;code&gt;while/else&lt;/code&gt;, &lt;code&gt;for/else&lt;/code&gt; ，可以讓 Code 更簡潔&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;以登入為例&quot;&gt;&lt;/a&gt;以登入為例&lt;/h2&gt;&lt;p&gt;以登入來說，由於受限於第三方回傳登入成功，需要 While loop 等待：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;start&amp;#95;login&amp;#40;&amp;#41;
while is&amp;#95;logging&amp;#95;in:
    if is&amp;#95;logged&amp;#95;in:
        print&amp;#40;&amp;quot;Successfully logged in!&amp;quot;&amp;#41;
        break&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在登入函數中，會設置 &lt;code&gt;is&amp;#95;logged&amp;#95;in&lt;/code&gt; 來觸發進到前面 while loop 中的 if break：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import time

is&amp;#95;logging&amp;#95;in = False
is&amp;#95;logged&amp;#95;in = False

def start&amp;#95;login&amp;#40;&amp;#41;:
    global is&amp;#95;logging&amp;#95;in, is&amp;#95;logged&amp;#95;in
    print&amp;#40;&amp;quot;Logging in...&amp;quot;&amp;#41;
    is&amp;#95;logging&amp;#95;in = True
    time.sleep&amp;#40;3&amp;#41; # 模擬等 3 秒成功登入
    is&amp;#95;logged&amp;#95;in = True&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假如我們考慮登入失敗：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;def fail&amp;#95;to&amp;#95;login&amp;#40;&amp;#41;:
    global is&amp;#95;logging&amp;#95;in, is&amp;#95;logged&amp;#95;in
    print&amp;#40;&amp;quot;Logging in...&amp;quot;&amp;#41;
    is&amp;#95;logging&amp;#95;in = True
    time.sleep&amp;#40;3&amp;#41; # 模擬等 3 秒失敗登入
    is&amp;#95;logging&amp;#95;in = False&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那我們就可以使用 &lt;code&gt;while/else&lt;/code&gt; 來處理，而不需要再兩三行的 &lt;code&gt;if/else&lt;/code&gt; ：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;fail&amp;#95;to&amp;#95;login&amp;#40;&amp;#41;
while is&amp;#95;logging&amp;#95;in:
    if is&amp;#95;logged&amp;#95;in:
        is&amp;#95;logging&amp;#95;in = False
        print&amp;#40;&amp;quot;Successfully logged in!&amp;quot;&amp;#41;
        break
else:　　　　　　　　　　　　　　 # &amp;lt;---- while/else
       print&amp;#40;&amp;quot;Failed to log in!&amp;quot;&amp;#41; # &amp;lt;---- while/else&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;除此之外也可以使用 &lt;code&gt;for/else&lt;/code&gt; 處理經常需要遍歷資料，但是遍歷後沒有找到的情況。&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 04 Dec 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-12-03-在-Python-中使用-Screen-Brightness-Control-自動偵測閃電下單視窗並調高亮度/
</guid>
<link>
http://lisp.rocks/posts-output/2023-12-03-在-Python-中使用-Screen-Brightness-Control-自動偵測閃電下單視窗並調高亮度/
</link>
<title>
在 Python 中自動偵測閃電下單視窗，並調高亮度
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;python&amp;#95;套件&amp;#95;&lt;code&gt;screen&amp;#95;brightness&amp;#95;control&lt;/code&gt;&quot;&gt;&lt;/a&gt;Python 套件 &lt;code&gt;screen&amp;#95;brightness&amp;#95;control&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;在 Python 中透過亮度控制套件 (&lt;a href='https://github.com/Crozzers/screen_brightness_control'&gt;GitHub&lt;/a&gt;) 可以設定並取得螢幕亮度：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import screen&amp;#95;brightness&amp;#95;control as sbc

# get the brightness
brightness = sbc.get&amp;#95;brightness&amp;#40;&amp;#41;
# get the brightness for the primary monitor
primary = sbc.get&amp;#95;brightness&amp;#40;display=0&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;自動偵測視窗並調整亮度&quot;&gt;&lt;/a&gt;自動偵測視窗並調整亮度&lt;/h2&gt;&lt;p&gt;由於做交易時會有許多顯示器，亮度可以設置成全亮的 80-90%&lt;/p&gt;&lt;p&gt;然後可以設置成當該顯示器打開的視窗發生重要事件時，將亮度調高到 100% 提醒自己&lt;/p&gt;&lt;p&gt;這邊以 &quot;閃電下單&quot; 為例, 閃電下單視窗名稱是 &quot;閃電下單 1&quot;, &quot;閃電下單 2&quot; &amp;#x2026; 等，匹配名字即可：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import time
import screen&amp;#95;brightness&amp;#95;control as sbc
import win32gui

# Inputs
programName = &amp;quot;閃電下單&amp;quot;
defaultBrightness = 90 # 預設亮度, 80-90%
targetBrightness = 100 # 當打開閃電下單, 亮度調亮吸引注意力

# Program
pid = None
lastCheck = time.time&amp;#40;&amp;#41;
printPerSec = 15
while True:
    monitors = sbc.list&amp;#95;monitors&amp;#40;&amp;quot;wmi&amp;quot;&amp;#41;
    hwnd = win32gui.GetForegroundWindow&amp;#40;&amp;#41;
    title = win32gui.GetWindowText&amp;#40;hwnd&amp;#41;
    if time.time&amp;#40;&amp;#41; &amp;gt;= lastCheck:
        lastCheck += printPerSec
        print&amp;#40;f&amp;quot;當前視窗: {title} &amp;#40;顯示器={monitors}&amp;#41;&amp;quot;&amp;#41;
    if programName in title and pid is None:
        print&amp;#40;f&amp;quot;將 '{title}' 所在顯示器的螢幕亮度，調整成 &amp;quot;+str&amp;#40;targetBrightness&amp;#41;&amp;#41;
        sbc.fade&amp;#95;brightness&amp;#40;targetBrightness, display=monitors&amp;#91;0&amp;#93;&amp;#41;
        if pid is None:
            pid = hwnd
    else:
        prevBrightness = sbc.get&amp;#95;brightness&amp;#40;display=monitors&amp;#91;0&amp;#93;&amp;#41;&amp;#91;0&amp;#93;
        if prevBrightness == targetBrightness and not programName in title:
            print&amp;#40;f&amp;quot;將 '{title}' 所在顯示器的螢幕亮度，恢復到預設值 &amp;quot;+str&amp;#40;defaultBrightness&amp;#41;&amp;#41;
            sbc.fade&amp;#95;brightness&amp;#40;defaultBrightness, display=monitors&amp;#91;0&amp;#93;&amp;#41;
            pid = None
    time.sleep&amp;#40;1&amp;#41;&lt;/code&gt;&lt;/pre&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sun, 03 Dec 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-12-02-使用-SimpleNamespace-分類管理券商-API-錯誤碼/
</guid>
<link>
http://lisp.rocks/posts-output/2023-12-02-使用-SimpleNamespace-分類管理券商-API-錯誤碼/
</link>
<title>
使用 SimpleNamespace 分類管理券商 API 錯誤碼
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;券商錯誤碼&quot;&gt;&lt;/a&gt;券商錯誤碼&lt;/h2&gt;&lt;p&gt;券商 API 錯誤碼通常是扁平（flat）的，也就是錯誤碼不會分類。&lt;/p&gt;&lt;p&gt;假設我們有以下券商錯誤碼，我們可能很自然使用 &lt;code&gt;dict&lt;/code&gt; 管理 mapping：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mapping = {
    1001: &amp;quot;登入失敗，請由LOG查看失敗原因。&amp;quot;,
    1002: &amp;quot;交易帳號不存在。&amp;quot;,
    1003: &amp;quot;下單帳號類型不正確，是否有證券帳號下期貨之情行。&amp;quot;,
    1004: &amp;quot;PERIOD 超出選擇範圍。&amp;quot;,
    1005: &amp;quot;FLAG 超出選擇範圍。&amp;quot;,
    1006: &amp;quot;BUYSELL 超出選擇範圍。&amp;quot;,
    1007: &amp;quot;下單主機不存在。&amp;quot;,
    1009: &amp;quot;TRADE TYPE 超出選擇範圍。&amp;quot;,
    1010: &amp;quot;DAY TRADE超出選擇範圍。&amp;quot;,
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是我們在使用的時候，是希望登入相關拋出 LoginFailError 然後觸發重新登入操作&lt;/p&gt;&lt;p&gt;而委託相關的 Error，應該拋出 OrderInvalidError 觸發重新設置參數的操作&lt;/p&gt;&lt;p&gt;也就是說，針對不同 Error Code 可能要有不同行為&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;使用&amp;#95;&lt;code&gt;simplenamespace&lt;/code&gt;&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;SimpleNamespace&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;如果要將 Error Code 分類管理，能使用 &lt;code&gt;SimpleNamespace&lt;/code&gt; ：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;from types import SimpleNamespace

class InSet&amp;#40;set&amp;#41;:
    def &amp;#95;&amp;#95;eq&amp;#95;&amp;#95;&amp;#40;self, elem&amp;#41;:
        return elem == self

APIError = SimpleNamespace&amp;#40;
    isLoginFail=InSet&amp;#40;{1001, 1002, 1003, 1007}&amp;#41;,
    isOrderInvalid=InSet&amp;#40;{1004, 1005, 1006, 1009, 1010}&amp;#41;
&amp;#41;

print&amp;#40;APIError&amp;#41;
# namespace&amp;#40;isLoginFail=InSet&amp;#40;{1001, 1002, 1003, 1007}&amp;#41;,
# isOrderInvalid=InSet&amp;#40;{1009, 1010, 1004, 1005, 1006}&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而 &lt;code&gt;InSet&lt;/code&gt; 的 &lt;code&gt;&amp;#95;&amp;#95;eq&amp;#95;&amp;#95;&lt;/code&gt; 能幫助我們快速讓 Error Code 進到對應的控制語句&lt;/p&gt;&lt;p&gt;在 3.10 以上就能使用 &lt;code&gt;match/case&lt;/code&gt; ：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;code = 1002

match code:
    case APIError.isLoginFail:
        print&amp;#40;f&amp;quot;The login fail error: {mapping&amp;#91;code&amp;#93;}&amp;quot;&amp;#41;
    case APIError.isOrderInvalid:
        print&amp;#40;f&amp;quot;The order invalid error: {mapping&amp;#91;code&amp;#93;}&amp;quot;&amp;#41;
    case &amp;#95;:
        print&amp;#40;&amp;quot;Unhandled error code&amp;quot;&amp;#41;
# 1002 is a login fail error: 交易帳號不存在。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或是在 3.10 以前可以使用 &lt;code&gt;if/else&lt;/code&gt; ：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;code = 1002

if code == APIError.isLoginFail:
    print&amp;#40;f&amp;quot;The login fail error: {mapping&amp;#91;code&amp;#93;}&amp;quot;&amp;#41;
elif code == APIError.isOrderInvalid:
    print&amp;#40;f&amp;quot;The order invalid error: {mapping&amp;#91;code&amp;#93;}&amp;quot;&amp;#41;
else:
    print&amp;#40;&amp;quot;Unhandled error code&amp;quot;&amp;#41;
# 1002 is a login fail error: 交易帳號不存在。&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;關於簡易命名空間&amp;#95;&lt;code&gt;simplenamespace&lt;/code&gt;&quot;&gt;&lt;/a&gt;關於簡易命名空間 &lt;code&gt;SimpleNamespace&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;SimpleNamespace&lt;/code&gt; 有以下比 &lt;code&gt;namedtuple&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt; 好的優勢：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;可以透過 . 訪問屬性，就像一般 Object 般使用&lt;/li&gt;&lt;li&gt;可以設定自帶初始化屬性&lt;/li&gt;&lt;li&gt;比起 class 又更輕量，訪問何存儲更快速&lt;/li&gt;&lt;li&gt;內建 &lt;code&gt;repr&amp;#40;&amp;#41;&lt;/code&gt; 就是屬性自己: &lt;code&gt;eval&amp;#40;repr&amp;#40;sn&amp;#41;&amp;#41;==sn&lt;/code&gt;&lt;/li&gt;&lt;li&gt;比對不是透過 id 而是透過屬性本身的值&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 02 Dec 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-12-01-利用-Python-可變預設參數特性，保留歷史報價與計算/
</guid>
<link>
http://lisp.rocks/posts-output/2023-12-01-利用-Python-可變預設參數特性，保留歷史報價與計算/
</link>
<title>
利用 Python 可變預設參數特性，保留歷史報價與計算
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;可變預設參數&amp;#95;(mutable&amp;#95;default&amp;#95;arguments)&quot;&gt;&lt;/a&gt;可變預設參數 (Mutable Default Arguments)&lt;/h2&gt;&lt;p&gt;函數的預設參數如果是可變物件 (Mutable Default Arguments)&lt;/p&gt;&lt;p&gt;在 Python 中就只會初始化一次，並不斷復用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;def doubled&amp;#40;val, the&amp;#95;list=&amp;#91;&amp;#93;&amp;#41;:
    the&amp;#95;list.append&amp;#40;val&amp;#41;
    the&amp;#95;list.append&amp;#40;val&amp;#41;
    return the&amp;#95;list

print&amp;#40;doubled&amp;#40;10&amp;#41;&amp;#41;
# &amp;#91;10, 10&amp;#93;

print&amp;#40;doubled&amp;#40;99&amp;#41;&amp;#41;
# &amp;#91;10, 10, 99, 99&amp;#93;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之所以會這樣，是因為函數是物件，預設參數如同屬性。&lt;/p&gt;&lt;p&gt;而常見的可變物件包含字典、列表等。&lt;/p&gt;&lt;p&gt;在一般情況中，我們都會鼓勵預設參數應該盡量使用不可變物件。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;利用該特性，保留歷史報價與計算&quot;&gt;&lt;/a&gt;利用該特性，保留歷史報價與計算&lt;/h2&gt;&lt;p&gt;然而在輕量處理快速大量湧入的報價時，反而可以利用這個機制&lt;/p&gt;&lt;p&gt;設計暫存區（Buffer）存放歷史報價在可變的預設參數：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# 計算平均 Bid Price
# 並保留最多 maxBuffer 個 Bid Price
def avgBid&amp;#40;newBid, lookback, histBids=&amp;#91;&amp;#93;, maxBuffer=10&amp;#41;:
    histBids.append&amp;#40;newBid&amp;#41;
    histBids = histBids&amp;#91;-maxBuffer:&amp;#93;
    lookback = min&amp;#40;lookback, len&amp;#40;histBids&amp;#41;&amp;#41;
    print&amp;#40;f&amp;quot;Bids: {histBids}&amp;quot;&amp;#41;
    avg = sum&amp;#40;histBids&amp;#91;-lookback:&amp;#93;&amp;#41; / lookback

    return avg

for x in range&amp;#40;2, 100, 7&amp;#41;:
    print&amp;#40;f&amp;quot;Avg Bid: {avgBid&amp;#40;x, 2&amp;#41;}&amp;quot;&amp;#41;

# 計算最近 2 個平均報價, 並保留 10 個歷史報價
#
# Bids: &amp;#91;2&amp;#93;
# Avg Bid: 2.0
# Bids: &amp;#91;2, 9&amp;#93;
# Avg Bid: 5.5
# Bids: &amp;#91;2, 9, 16&amp;#93;
# Avg Bid: 12.5
# Bids: &amp;#91;2, 9, 16, 23&amp;#93;
#
# ...
#
# Bids: &amp;#91;23, 30, 37, 44, 51, 58, 65, 72, 79, 86&amp;#93;
# Avg Bid: 82.5
# Bids: &amp;#91;30, 37, 44, 51, 58, 65, 72, 79, 86, 93&amp;#93;
# Avg Bid: 89.5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;顯然的潛在威脅：副作用&quot;&gt;&lt;/a&gt;顯然的潛在威脅：副作用&lt;/h2&gt;&lt;p&gt;請留意，這樣的操作潛在有 很大的副作用 ，例如：&lt;/p&gt;&lt;p&gt;函數重複呼叫，可能會混入重複或其他的輸入到 buffer 中&lt;/p&gt;&lt;p&gt;用 Thread 監聽並執行，並沒有 Thread safe&lt;/p&gt;&lt;p&gt;如果要盡可能降低副作用，可以考慮內嵌函數 (inner function) 的函數工廠&lt;/p&gt;&lt;p&gt;要用就生產一個，函數內的 buffer 間互相獨立：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import threading
import time

def avgBidFactory&amp;#40;&amp;#41;:
    def avgBid&amp;#40;id, newBid, lookback, histBids=&amp;#91;&amp;#93;, maxBuffer=10&amp;#41;:
        histBids.append&amp;#40;newBid&amp;#41;
        histBids = histBids&amp;#91;-maxBuffer:&amp;#93;
        print&amp;#40;f&amp;quot;&amp;#40;{id}&amp;#41; Bids: {histBids}&amp;quot;&amp;#41;
        lookback = min&amp;#40;lookback, len&amp;#40;histBids&amp;#41;&amp;#41;
        avg = sum&amp;#40;histBids&amp;#91;-lookback:&amp;#93;&amp;#41; / lookback
        return avg
    return avgBid

def test&amp;#40;id&amp;#41;:
    avgBidFunc = avgBidFactory&amp;#40;&amp;#41;
    for x in range&amp;#40;2, 100, 7&amp;#41;:
        print&amp;#40;f&amp;quot;&amp;#40;{id}&amp;#41; Avg Bid: {avgBidFunc&amp;#40;id, x, 2&amp;#41;}&amp;quot;&amp;#41;
        time.sleep&amp;#40;0.3&amp;#41;

t1 = threading.Thread&amp;#40;target=test, args=&amp;#40;1,&amp;#41;&amp;#41;.start&amp;#40;&amp;#41;
t2 = threading.Thread&amp;#40;target=test, args=&amp;#40;2,&amp;#41;&amp;#41;.start&amp;#40;&amp;#41;

# &amp;#40;2&amp;#41; Bids: &amp;#91;2, 9&amp;#93;
# &amp;#40;2&amp;#41; Avg Bid: 5.5
# &amp;#40;1&amp;#41; Bids: &amp;#91;2, 9&amp;#93;
# &amp;#40;1&amp;#41; Avg Bid: 5.5
# &amp;#40;2&amp;#41; Bids: &amp;#91;2, 9, 16&amp;#93;
# &amp;#40;1&amp;#41; Bids: &amp;#91;2, 9, 16&amp;#93;
# &amp;#40;1&amp;#41; Avg Bid: 12.5
# &amp;#40;2&amp;#41; Avg Bid: 12.5
#
# ...
#
# &amp;#40;1&amp;#41; Avg Bid: 82.5
# &amp;#40;2&amp;#41; Bids: &amp;#91;23, 30, 37, 44, 51, 58, 65, 72, 79, 86&amp;#93;
# &amp;#40;2&amp;#41; Avg Bid: 82.5
# &amp;#40;2&amp;#41; Bids: &amp;#91;30, 37, 44, 51, 58, 65, 72, 79, 86, 93&amp;#93;
# &amp;#40;1&amp;#41; Bids: &amp;#91;30, 37, 44, 51, 58, 65, 72, 79, 86, 93&amp;#93;
# &amp;#40;1&amp;#41; Avg Bid: 89.5
# &amp;#40;2&amp;#41; Avg Bid: 89.5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此得十分確定函數在掌握之中，最好是輕量、單一的函數。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;速度也不見得有優勢&quot;&gt;&lt;/a&gt;速度也不見得有優勢&lt;/h2&gt;&lt;p&gt;另外這樣並沒有比較快（通常是更慢）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import timeit
import statistics


# Method 1: 利用可變預設參數
def avgBid1&amp;#40;newBid, lookback, histBids=&amp;#91;&amp;#93;, maxBuffer=10&amp;#41;:
    histBids.append&amp;#40;newBid&amp;#41;
    histBids = histBids&amp;#91;-maxBuffer:&amp;#93;
    lookback = min&amp;#40;lookback, len&amp;#40;histBids&amp;#41;&amp;#41;
    avg = sum&amp;#40;histBids&amp;#91;-lookback:&amp;#93;&amp;#41; / lookback
    return avg

# Method 2: 一般寫法
def avgBid2&amp;#40;histBids, lookback&amp;#41;:
    lookback = min&amp;#40;lookback, len&amp;#40;histBids&amp;#41;&amp;#41;
    avg = sum&amp;#40;histBids&amp;#91;-lookback:&amp;#93;&amp;#41; / lookback
    return avg

def test1&amp;#40;&amp;#41;:
    for x in range&amp;#40;1, 10000, 3&amp;#41;:
        avgBid1&amp;#40;x, 7&amp;#41;

def test2&amp;#40;&amp;#41;:
    buffer = &amp;#91;&amp;#93;
    for x in range&amp;#40;1, 10000, 3&amp;#41;:
        buffer.append&amp;#40;x&amp;#41;
        buffer = buffer&amp;#91;-10:&amp;#93;
        avg = avgBid2&amp;#40;buffer, 7&amp;#41;

executionTimes1 = &amp;#91;timeit.timeit&amp;#40;test1, number=1000&amp;#41; for &amp;#95; in range&amp;#40;10&amp;#41;&amp;#93;
mean1 = statistics.stdev&amp;#40;executionTimes1&amp;#41;
stdDev1 = statistics.stdev&amp;#40;executionTimes1&amp;#41;
print&amp;#40;f&amp;quot;Time1: {mean1:.6f} ±{2&amp;#42;stdDev1:.6f} s&amp;quot;&amp;#41;
# 利用可變預設參數 Time1: 0.084309 ±0.168618 s

executionTimes2 = &amp;#91;timeit.timeit&amp;#40;test2, number=1000&amp;#41; for &amp;#95; in range&amp;#40;10&amp;#41;&amp;#93;
mean2 = statistics.stdev&amp;#40;executionTimes2&amp;#41;
stdDev2 = statistics.stdev&amp;#40;executionTimes2&amp;#41;
print&amp;#40;f&amp;quot;Time2: {mean2:.6f} ±{2&amp;#42;stdDev2:.6f} s&amp;quot;&amp;#41;
# 一般寫法 Time2: 0.021163 ±0.042325 s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;結論：危機就是轉機，謹慎用之&quot;&gt;&lt;/a&gt;結論：危機就是轉機，謹慎用之&lt;/h2&gt;&lt;p&gt;視情況可謹慎使用，例如在業務起頭或末端的輕量處理，就可以考慮。&lt;/p&gt;&lt;p&gt;例如：算完就 print, 寫 file, 送出到網路 … 等。&lt;/p&gt;&lt;p&gt;就不需要特地還要建立一個前值變數保存，然後運算完更新前值，然後前值又暴露在一堆地方。&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Fri, 01 Dec 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-11-30-使用-SymPy-推導選擇權價格公式並試算/
</guid>
<link>
http://lisp.rocks/posts-output/2023-11-30-使用-SymPy-推導選擇權價格公式並試算/
</link>
<title>
使用 SymPy 推導選擇權價格公式並試算
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;使用套件&quot;&gt;&lt;/a&gt;使用套件&lt;/h2&gt;&lt;p&gt;透過 SymPy 我們可以進行數學符號運算，並建立公式的 symbol&lt;/p&gt;&lt;pre&gt;&lt;code&gt;from sympy import symbols, exp, sqrt, ln, N
from sympy.stats import Normal, cdf&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;公式推導&quot;&gt;&lt;/a&gt;公式推導&lt;/h2&gt;&lt;p&gt;透過 symbols 建立變數， &lt;code&gt;positive&lt;/code&gt; 說明變數都是正數。&lt;/p&gt;&lt;p&gt;其中關鍵是讓 &lt;code&gt;Normal&lt;/code&gt; 參與進來，有統計分配，可以自由調用 cdf 來作為 cdf 函數。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;S0, X, T, r, sigma = symbols&amp;#40;'S0 X T r sigma', positive=True&amp;#41;

d1 = &amp;#40;ln&amp;#40;S0 / X&amp;#41; + &amp;#40;r + sigma&amp;#42;&amp;#42;2 / 2&amp;#41; &amp;#42; T&amp;#41; / &amp;#40;sigma &amp;#42; sqrt&amp;#40;T&amp;#41;&amp;#41;
d2 = d1 - sigma &amp;#42; sqrt&amp;#40;T&amp;#41;
norm&amp;#95;dist = Normal&amp;#40;'StdNormal', 0, 1&amp;#41;

C = S0 &amp;#42; cdf&amp;#40;norm&amp;#95;dist&amp;#41;&amp;#40;d1&amp;#41; - X &amp;#42; exp&amp;#40;-r &amp;#42; T&amp;#41; &amp;#42; cdf&amp;#40;norm&amp;#95;dist&amp;#41;&amp;#40;d2&amp;#41;
P = X &amp;#42; exp&amp;#40;-r &amp;#42; T&amp;#41; &amp;#42; cdf&amp;#40;norm&amp;#95;dist&amp;#41;&amp;#40;-d2&amp;#41; - S0 &amp;#42; cdf&amp;#40;norm&amp;#95;dist&amp;#41;&amp;#40;-d1&amp;#41;

print&amp;#40;f&amp;quot;買權價格公式: {C}&amp;quot;&amp;#41;
print&amp;#40;f&amp;quot;賣權價格公式: {P}&amp;quot;&amp;#41;

# 買權價格公式: S0&amp;#42;&amp;#40;erf&amp;#40;sqrt&amp;#40;2&amp;#41;&amp;#42;&amp;#40;T&amp;#42;&amp;#40;r + sigma&amp;#42;&amp;#42;2/2&amp;#41; + log&amp;#40;S0/X&amp;#41;&amp;#41;/&amp;#40;2&amp;#42;sqrt&amp;#40;T&amp;#41;&amp;#42;sigma&amp;#41;&amp;#41;/2 + 1/2&amp;#41;- X&amp;#42;&amp;#40;erf&amp;#40;sqrt&amp;#40;2&amp;#41;&amp;#42;&amp;#40;-sqrt&amp;#40;T&amp;#41;&amp;#42;sigma + &amp;#40;T&amp;#42;&amp;#40;r + sigma&amp;#42;&amp;#42;2/2&amp;#41; + log&amp;#40;S0/X&amp;#41;&amp;#41;/&amp;#40;sqrt&amp;#40;T&amp;#41;&amp;#42;sigma&amp;#41;&amp;#41;/2&amp;#41;/2 + 1/2&amp;#41;&amp;#42;exp&amp;#40;-T&amp;#42;r&amp;#41;
# 賣權價格公式: -S0&amp;#42;&amp;#40;1/2 - erf&amp;#40;sqrt&amp;#40;2&amp;#41;&amp;#42;&amp;#40;T&amp;#42;&amp;#40;r + sigma&amp;#42;&amp;#42;2/2&amp;#41; + log&amp;#40;S0/X&amp;#41;&amp;#41;/&amp;#40;2&amp;#42;sqrt&amp;#40;T&amp;#41;&amp;#42;sigma&amp;#41;&amp;#41;/2&amp;#41; + X&amp;#42;&amp;#40;erf&amp;#40;sqrt&amp;#40;2&amp;#41;&amp;#42;&amp;#40;sqrt&amp;#40;T&amp;#41;&amp;#42;sigma - &amp;#40;T&amp;#42;&amp;#40;r + sigma&amp;#42;&amp;#42;2/2&amp;#41; + log&amp;#40;S0/X&amp;#41;&amp;#41;/&amp;#40;sqrt&amp;#40;T&amp;#41;&amp;#42;sigma&amp;#41;&amp;#41;/2&amp;#41;/2 + 1/2&amp;#41;&amp;#42;exp&amp;#40;-T&amp;#42;r&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;價格試算&quot;&gt;&lt;/a&gt;價格試算&lt;/h2&gt;&lt;p&gt;價格計算只需要把變數名稱一一對應，就能計算而得。&lt;/p&gt;&lt;p&gt;帶入條件後，還得透過 &lt;code&gt;N&lt;/code&gt; 才會具體取得數值結果。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;S0&amp;#95;val = 100
X&amp;#95;val = 100
T&amp;#95;val = 1
r&amp;#95;val = 0.05
sigma&amp;#95;val = 0.2

conditions = {S0: S0&amp;#95;val, X: X&amp;#95;val, T: T&amp;#95;val, r: r&amp;#95;val, sigma: sigma&amp;#95;val}

C&amp;#95;val = C.subs&amp;#40;conditions&amp;#41;
P&amp;#95;val = P.subs&amp;#40;conditions&amp;#41;

C&amp;#95;numerical = N&amp;#40;C&amp;#95;val&amp;#41;
P&amp;#95;numerical = N&amp;#40;P&amp;#95;val&amp;#41;

print&amp;#40;f&amp;quot;給定條件: {conditions}&amp;quot;&amp;#41;
print&amp;#40;f&amp;quot;買權價格: $ {C&amp;#95;numerical:.2f}&amp;quot;&amp;#41;
print&amp;#40;f&amp;quot;賣權價格: $ {P&amp;#95;numerical:.2f}&amp;quot;&amp;#41;

# 給定條件: {S0: 100, X: 100, T: 1, r: 0.05, sigma: 0.2}
# 買權價格: $ 10.45
# 賣權價格: $ 5.57&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 30 Nov 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2023-11-26-使用-bisect-快速匹配商品編號前2-3碼並提前訂閱/
</guid>
<link>
http://lisp.rocks/posts-output/2023-11-26-使用-bisect-快速匹配商品編號前2-3碼並提前訂閱/
</link>
<title>
使用 bisect 快速匹配商品編號前 2-3 碼並提前訂閱
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;../../img/not-by-ai/tw/written-by-human/svg/Written-By-Human-Not-By-AI-Badge-white.svg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;關於&amp;#95;&lt;code&gt;bisect&lt;/code&gt;&quot;&gt;&lt;/a&gt;關於 &lt;code&gt;bisect&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;在 Python 中 &lt;code&gt;bisect&lt;/code&gt; 有很多種用法，詳細請見 &lt;a href='https://martinheinz.dev/blog/106'&gt;Everything You Can Do with Python's bisect Module&lt;/a&gt;&lt;/p&gt;&lt;p&gt;其中一個功能就是對於 str array 快速匹配前綴，並將符合的字串篩選出來。&lt;/p&gt;&lt;p&gt;當 array 很大時，這個方法基本上都比迭代來的快。&lt;/p&gt;&lt;p&gt;對於快速匹配股票商品編號，並向券商訂閱報價資訊來說就很方便，例如當使用者輸入 &quot;2&quot; &quot;3&quot; &quot;3&quot;&lt;/p&gt;&lt;p&gt;就能將其匹配到['2330', '2331', '2332', '2337', '2338', '23383'] 這些商品編號&lt;/p&gt;&lt;p&gt;進而先提前訂閱這些商品的報價和五檔。&lt;/p&gt;&lt;p&gt;當使用者輸入到 2330 時，報價就已經訂閱，再把剩餘的 2331, 2332, &amp;#x2026; 解訂即可。&lt;/p&gt;&lt;p&gt;對於商品檔有幾萬來說，是很方便的功能。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;def prefixSearch&amp;#40;words: list&amp;#91;str&amp;#93;, prefix: str, isSorted: bool = False&amp;#41; -&amp;gt; list&amp;#91;str&amp;#93;:
    if not isSorted:
          words.sort&amp;#40;&amp;#41;
    start = bisect&amp;#95;left&amp;#40;words, prefix&amp;#41;
    matches = &amp;#91;&amp;#93;
    for i, s in enumerate&amp;#40;words&amp;#91;start:&amp;#93;&amp;#41;:
        if s.startswith&amp;#40;prefix&amp;#41;:
            matches.append&amp;#40;s&amp;#41;
        else:
            break
    return matches&lt;/code&gt;&lt;/pre&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sun, 26 Nov 2023 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-11-07-在-Emacs-中使用-counsel-gtags/
</guid>
<link>
http://lisp.rocks/posts-output/2018-11-07-在-Emacs-中使用-counsel-gtags/
</link>
<title>
在 Emacs 中使用 counsel-gtags
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h2&gt;&lt;a name=&quot;建立&amp;#95;gtag&amp;#95;檔案&quot;&gt;&lt;/a&gt;建立 GTAG 檔案&lt;/h2&gt;&lt;p&gt;首先你得先透過 &lt;code&gt;counsel-gtags-create-tags&lt;/code&gt; 來在根目錄建立 GTAGS 檔案&lt;/p&gt;&lt;p&gt;可能會花一點時間，這時 GTAGS 檔案可能是空的，不要緊張&lt;/p&gt;&lt;p&gt;建立完畢後就能使用 &lt;code&gt;counsel-gtags-find-definition&lt;/code&gt; &lt;/p&gt;&lt;p&gt;在游標處立即對該游標前的函數定義處進行跳轉&lt;/p&gt;&lt;p&gt;我個人是把他綁定到 &lt;code&gt;M-t&lt;/code&gt; 方便快速跳轉到函數定義位置&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 07 Nov 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-02-13-〈微軟測試之道〉閱讀筆記/
</guid>
<link>
http://lisp.rocks/posts-output/2018-02-13-〈微軟測試之道〉閱讀筆記/
</link>
<title>
〈微軟測試之道〉閱讀筆記
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h2&gt;&lt;a name=&quot;測試工程師常見的任務&quot;&gt;&lt;/a&gt;測試工程師常見的任務&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;開發測試工具&lt;/li&gt;&lt;li&gt;開發針對安全或性能測試的工具&lt;/li&gt;&lt;li&gt;API 或協議測試的自動化&lt;/li&gt;&lt;li&gt;BUG 大掃除 ( bug bashes )&lt;/li&gt;&lt;li&gt;撰寫測試計畫&lt;/li&gt;&lt;li&gt;寫測試案例的文件&lt;/li&gt;&lt;li&gt;執行手工測試&lt;/li&gt;&lt;li&gt;核心測試範例自動化&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;從這裡面我可以切出 8 張票&lt;/p&gt;&lt;pre&gt;&lt;code&gt;- &amp;#91; &amp;#93; 1, 撰寫 scripts 自動測試
    - &amp;#91; &amp;#93; 1.1. 單元測試
    - &amp;#91; &amp;#93; 1.2. 效能測試
    - &amp;#91; &amp;#93; 1.3. 安全測試
- &amp;#91; &amp;#93; 2. API 測試自動化
- &amp;#91; &amp;#93; 3. 安排時間 Bug bashes &amp;#40;大家一起找 bug&amp;#41;
- &amp;#91; &amp;#93; 撰寫測試計畫
    - &amp;#91; &amp;#93; 添加到規格書中
- &amp;#91; &amp;#93; 寫測試案例的文件
    - &amp;#91; &amp;#93; 針對核心測試範例寫文件&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;里程碑模式&quot;&gt;&lt;/a&gt;里程碑模式&lt;/h2&gt;&lt;p&gt;對項目的版本做規劃，每個里程碑都要有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;階段標準 Exit Criteria&lt;ul&gt;&lt;li&gt;關鍵功能完畢&lt;/li&gt;&lt;li&gt;中期測試目標達到 ( 代碼覆蓋率 + 測試完成率達標 )&lt;/li&gt;&lt;li&gt;缺陷目標達到 ( 無 P1 Bug , 第一嚴重 BUg )&lt;/li&gt;&lt;li&gt;非功能目標達到 ( 性能, 負荷測試完成, 無嚴重問題 )&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;各里程碑(M1,M2,M3,Release) 的目標&lt;/p&gt;&lt;ul&gt;&lt;li&gt;M0&lt;ul&gt;&lt;li&gt;準備各種定義&lt;ul&gt;&lt;li&gt;目標文件&lt;/li&gt;&lt;li&gt;專案管理流程&lt;/li&gt;&lt;li&gt;發布目標&lt;/li&gt;&lt;li&gt;功能規格書&lt;/li&gt;&lt;li&gt;功能優先次序表&lt;/li&gt;&lt;li&gt;里程碑進度&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;M1&lt;ul&gt;&lt;li&gt;執行：無要求&lt;/li&gt;&lt;li&gt;覆蓋：都能測量並生成報告&lt;/li&gt;&lt;li&gt;可靠性：無要求&lt;/li&gt;&lt;li&gt;功能：無要求&lt;/li&gt;&lt;li&gt;性能：完成性能測試並生成報告&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;M2&lt;ul&gt;&lt;li&gt;執行：P1 Case 都能執行&lt;/li&gt;&lt;li&gt;覆蓋：65%&lt;/li&gt;&lt;li&gt;可靠性：解決 M1 中 50% Issue&lt;/li&gt;&lt;li&gt;功能：20% 擁有公開介面&lt;/li&gt;&lt;li&gt;性能：確立性能基準線與目標性能&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;M3&lt;ul&gt;&lt;li&gt;執行：P1 Case + P2 Case 都能執行&lt;/li&gt;&lt;li&gt;覆蓋：75%&lt;/li&gt;&lt;li&gt;可靠性：解決 M2 中 50% Issue&lt;/li&gt;&lt;li&gt;功能：50% 擁有公開介面&lt;/li&gt;&lt;li&gt;性能：全面性能測試自動化完成&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Private Build:&lt;ul&gt;&lt;li&gt;一個介在 M3 與 Release 之間的版本&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Release:&lt;ul&gt;&lt;li&gt;所有 Case 都能執行&lt;/li&gt;&lt;li&gt;覆蓋：80%&lt;/li&gt;&lt;li&gt;解決 M3 中 70% Issue&lt;/li&gt;&lt;li&gt;功能：100% 公開介面&lt;/li&gt;&lt;li&gt;性能：全面性能目標達到&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;MQ:&lt;ul&gt;&lt;li&gt;Release 之後到下個階段之前，空檔時間能還債&lt;/li&gt;&lt;li&gt;大量 debug&lt;/li&gt;&lt;li&gt;規劃一個 Code Review 流程&lt;/li&gt;&lt;li&gt;衡量所有 bug 哪些 bug 可以在更早之前里程碑解決掉, 並找到衡量方法&lt;ul&gt;&lt;li&gt;例如 for 迴圈 20 行&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;質量門檻&quot;&gt;&lt;/a&gt;質量門檻&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;L1 所有測試都通過&lt;/li&gt;&lt;li&gt;L2 功能性 Bug 都修復, Issue 都關閉&lt;/li&gt;&lt;li&gt;L3 性能要求達標&lt;/li&gt;&lt;li&gt;L4 測試計畫書完成，對所有測試都有提供說明&lt;/li&gt;&lt;li&gt;L5 所有程式碼都通過審查&lt;/li&gt;&lt;li&gt;L6 文件完成&lt;/li&gt;&lt;li&gt;L7 安全性的應對計畫已完成&lt;/li&gt;&lt;li&gt;L8 代碼覆蓋率達 80%&lt;/li&gt;&lt;li&gt;L9 所有功能在不同環境中都能正常運作&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;宏觀視野&quot;&gt;&lt;/a&gt;宏觀視野&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;開發人員的輸出粒度：&lt;ul&gt;&lt;li&gt;程式碼 Code&lt;/li&gt;&lt;li&gt;函數 functionality&lt;/li&gt;&lt;li&gt;產品功能 feature&lt;ul&gt;&lt;li&gt;戰術：怎麼工作的更有效率&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;專案 Project&lt;ul&gt;&lt;li&gt;戰略&amp;戰術&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;產品線 Product&lt;ul&gt;&lt;li&gt;長期戰略&lt;/li&gt;&lt;li&gt;業務需求&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;各階段版本&quot;&gt;&lt;/a&gt;各階段版本&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;LKG (Last Know Good) 已知最近一個符合特定質量標準的版本&lt;ul&gt;&lt;li&gt;L1 LKG, L2 LKG, L3 LKG, L4 LKG &amp;#x2026;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Self-host 自用版 - 內部團隊可以在日常生活中使用的版本&lt;/li&gt;&lt;li&gt;Visual freeze 介面凍結版本&lt;ul&gt;&lt;li&gt;在某個時間點開始視覺效果和 API 介面被凍結, 在發行前不再改變&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;debug build 除錯版 裡面支援很多除錯功能的版本&lt;/li&gt;&lt;li&gt;free build 銷售版 為發行而做各種最後優化得到的版本&lt;/li&gt;&lt;li&gt;Alpha 目標是得到功能和可用性的初步回饋的版本&lt;/li&gt;&lt;li&gt;Beta 預定發布的版本，希望得到反饋&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;測試規格&quot;&gt;&lt;/a&gt;測試規格&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;目標與摘要&lt;/li&gt;&lt;li&gt;策略&lt;/li&gt;&lt;li&gt;功能測試&lt;/li&gt;&lt;li&gt;元件測試&lt;/li&gt;&lt;li&gt;整合測試&lt;/li&gt;&lt;li&gt;互操作性測試&lt;/li&gt;&lt;li&gt;一致性測試&lt;/li&gt;&lt;li&gt;國際化測試/全球化測試&lt;/li&gt;&lt;li&gt;性能測試&lt;/li&gt;&lt;li&gt;安全測試&lt;/li&gt;&lt;li&gt;安全或部屬測試&lt;/li&gt;&lt;li&gt;依賴關係釐清&lt;/li&gt;&lt;li&gt;各種度量方法&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;測試用例&quot;&gt;&lt;/a&gt;測試用例&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;驗證測試&lt;/li&gt;&lt;li&gt;錯誤避免測試&lt;/li&gt;&lt;li&gt;開心路徑&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;功能測試&quot;&gt;&lt;/a&gt;功能測試&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;等價類劃分 Equivalence class partitioning ECP&lt;ul&gt;&lt;li&gt;如何對等價類劃分為合法和非法子集? 變數分解&lt;ul&gt;&lt;li&gt;過量分解會造成 false negatives / false positives&lt;/li&gt;&lt;li&gt;總是避免冗餘測試&lt;/li&gt;&lt;li&gt;四種啟發式方法&lt;ul&gt;&lt;li&gt;範圍&lt;/li&gt;&lt;li&gt;分組&lt;/li&gt;&lt;li&gt;唯一值&lt;/li&gt;&lt;li&gt;特殊值&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;子集分類以 v 開頭 ex: v1, v2, v3, v4&lt;/li&gt;&lt;li&gt;建立 &quot;測試設計矩陣&quot;&lt;/li&gt;&lt;li&gt;ECP 目的主要是暴露 &quot;單點故障&quot;&lt;ul&gt;&lt;li&gt;單點故障假設 : 通常系統很少是 2 或多個故障共同作用的結果&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;邊界值分析 BVA&lt;ul&gt;&lt;li&gt;邊界值的測試數量可以用 4n+1 來計算, n = 獨立參數個數&lt;/li&gt;&lt;li&gt;建立 BVA 測試矩陣&lt;/li&gt;&lt;li&gt;隱性邊界&lt;ul&gt;&lt;li&gt;不是所有邊界都能透過數字輸入輸出確定&lt;/li&gt;&lt;li&gt;例如視窗高低, 循環指令的邊界&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;the deja-vu heuristic 定義最小邊界值和忽上忽下於邊界值的數值&lt;ul&gt;&lt;li&gt;循環指令的邊界以內, 不准進入錯誤處理分支&lt;/li&gt;&lt;li&gt;循環指令的邊界上和外，必須初始化錯誤處理分支&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;組合分析&lt;ul&gt;&lt;li&gt;對於半耦合 (semicouple) 的參數的測試方法&lt;ul&gt;&lt;li&gt;分支測試 EC&lt;ul&gt;&lt;li&gt;對每個變數都測試至少一次&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;基準測試 BC&lt;ul&gt;&lt;li&gt;指定一組變數作為基準來測試&lt;/li&gt;&lt;li&gt;通常是快樂路徑常用的變量狀態組合&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;正交陳列 OA&lt;/li&gt;&lt;li&gt;組合測試 t=n&lt;ul&gt;&lt;li&gt;可以隨機化生成這些矩陣, 方便提高廣度&lt;/li&gt;&lt;li&gt;矩陣中的配對, 可以盡可能找到合適的覆蓋率&lt;/li&gt;&lt;li&gt;以及可以接受的未覆蓋函數量&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;窮舉測試 AC&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;標準覆蓋率&lt;ul&gt;&lt;li&gt;這個階段主要依賴腳本化測試&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;實際可達覆蓋率&lt;ul&gt;&lt;li&gt;這個階段透過探索性測試&lt;/li&gt;&lt;li&gt;並再依定情況開始採用結構測試&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;結構測試&quot;&gt;&lt;/a&gt;結構測試&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;塊狀測試 Block Test&lt;ul&gt;&lt;li&gt;針對程式碼中的一個個 Block 做測試&lt;/li&gt;&lt;li&gt;另一個重要性是在異常處理 Exception Handling&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;決策測試 Decision Testing&lt;ul&gt;&lt;li&gt;主要對 if/else 來測試&lt;/li&gt;&lt;li&gt;不能有效評估複合條件判斷流程&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;條件測試 Condition Testing&lt;ul&gt;&lt;li&gt;多個條件語句 AND/OR 組合而成&lt;/li&gt;&lt;li&gt;劃出控制流程圖&lt;/li&gt;&lt;li&gt;在寫出函數中各個條件的 true/false 的測試矩陣以及期待值&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;基礎路徑測試 Basic Path Testing&lt;ul&gt;&lt;li&gt;對整個控制流程進行測試&lt;/li&gt;&lt;li&gt;圈複雜度 cyclomatic complexity&lt;/li&gt;&lt;li&gt;基礎路徑技術 baseline path technique&lt;/li&gt;&lt;li&gt;簡化基礎路徑技術 simplified baseline path technique&lt;/li&gt;&lt;li&gt;實用基礎路徑技術 practical baseline path technique&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;程式碼複雜度&quot;&gt;&lt;/a&gt;程式碼複雜度&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;LOC 程式碼行數&lt;/li&gt;&lt;li&gt;圈複雜度 cyclomatic complexity&lt;ul&gt;&lt;li&gt;1-10 低風險&lt;/li&gt;&lt;li&gt;11-20 中等複雜度&lt;/li&gt;&lt;li&gt;21-50 高度複雜度&lt;/li&gt;&lt;li&gt;50+ 非常高風險/不可測試&lt;/li&gt;&lt;li&gt;圈複雜度高不代表缺陷就多&lt;ul&gt;&lt;li&gt;煙霧警告度量：煙多不保證火災&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Halstead 測量&lt;ul&gt;&lt;li&gt;主要用於衡量可維護姓&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;對物件的測量&lt;ul&gt;&lt;li&gt;類權重方法 WMC 類中的方法數&lt;/li&gt;&lt;li&gt;繼承樹深度 DIT 一個類繼承的類總數&lt;/li&gt;&lt;li&gt;物件間耦合度 CBO 一個類引用其他類的總數&lt;/li&gt;&lt;li&gt;扇入扇出 fan-in/fan-out 衡量一個類有調用到其他類多少次&lt;ul&gt;&lt;li&gt;如果一個類方法被調用 5 次而這 5 次會造成他調用其他 10 個類&lt;/li&gt;&lt;li&gt;那扇入就是 5 而扇出就是 10&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;基於模型的測試&quot;&gt;&lt;/a&gt;基於模型的測試&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;MBT Model-based testing&lt;/li&gt;&lt;li&gt;基於模型的刺是不是為了 end-to-end scenario&lt;/li&gt;&lt;li&gt;而是為了中間的過程變化&lt;/li&gt;&lt;li&gt;smart monkey test 聰明猴子測試, 隨機行走&lt;ul&gt;&lt;li&gt;在整個模型流程中隨機執行跳轉各步驟&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;bug&amp;#95;處理流程&quot;&gt;&lt;/a&gt;Bug 處理流程&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;運行測試 -&gt; 建立 bug 報告 -&gt; 三方會審 triage&lt;/li&gt;&lt;li&gt;重現 Reproduction&lt;ul&gt;&lt;li&gt;How Found: 怎麼重現錯誤&lt;/li&gt;&lt;li&gt;Issue Type: 程式碼問題, 設計問題, 文件問題&lt;/li&gt;&lt;li&gt;Bug Type: 安全, 性能, 功能 &amp;#x2026;&lt;/li&gt;&lt;li&gt;Source: 測試來源&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;缺陷沒有被批准就不修正&lt;ul&gt;&lt;li&gt;重複的 bug (duplicate)&lt;/li&gt;&lt;li&gt;推遲 Postpone&lt;/li&gt;&lt;li&gt;外部錯誤 External&lt;/li&gt;&lt;li&gt;設計錯誤 By Design&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;批准了就要開始調查 inverstigation approved 看是什麼問題&lt;ul&gt;&lt;li&gt;必須修正 Must Fix&lt;/li&gt;&lt;li&gt;應修正 Should Fix&lt;/li&gt;&lt;li&gt;有時間就修正 Fix if time&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;提出如何修正&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;缺陷的衡量&amp;#95;metric&quot;&gt;&lt;/a&gt;缺陷的衡量 Metric&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;修復的缺陷/所有解決的缺陷相對其他 Issue 的比例&lt;ul&gt;&lt;li&gt;用這個來衡量開發處於早期還是晚期&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;各種程式語言/平台的缺陷比例&lt;ul&gt;&lt;li&gt;衡量環境問題和開發的是否有特定領域瓶頸&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;缺陷發現率&lt;ul&gt;&lt;li&gt;太高或太低都要擔心, 對峰值進行解釋&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;錯誤修正率&lt;ul&gt;&lt;li&gt;當標準提高後, 修正比例應該下降&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;根據不同領域來看缺陷數&lt;ul&gt;&lt;li&gt;可能那個領域需要更多測試或協助&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;不同嚴重性的缺陷數&lt;ul&gt;&lt;li&gt;隨著發展嚴重性S1,S2 應該要像降, 而S3,S4會上升 Severity&lt;/li&gt;&lt;li&gt;一般期待在早期發現更多嚴重的缺陷&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;缺陷重新復發比率&lt;ul&gt;&lt;li&gt;這是一個衡量程序修正質量很好的標準&lt;/li&gt;&lt;li&gt;當專案快要結束時, 這個會開始變多和達到最大&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;平均反映缺陷時間&lt;ul&gt;&lt;li&gt;跟蹤開發團隊對缺陷的反應速度&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;平均關閉缺陷時間&lt;ul&gt;&lt;li&gt;反映大家對問題的解決速度&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;缺陷門檻 (缺陷 bars)&lt;ul&gt;&lt;li&gt;指一個開發人員在一定時間內所能接受的缺陷數量&lt;/li&gt;&lt;li&gt;當超過這個數量介會被停止開發功能, 必須立即修補缺陷&lt;/li&gt;&lt;li&gt;但也可能被濫用, 大家分工缺陷量&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;測試用例模板&quot;&gt;&lt;/a&gt;測試用例模板&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;測試用例編號&lt;/li&gt;&lt;li&gt;功能區&lt;/li&gt;&lt;li&gt;功能分區&lt;/li&gt;&lt;li&gt;優先級 (1,2,3,4)&lt;/li&gt;&lt;li&gt;類別 (功能性?性能?負載?)&lt;/li&gt;&lt;li&gt;頻率 (每次構建?)&lt;ul&gt;&lt;li&gt;版本驗證測試 BVT&lt;/li&gt;&lt;li&gt;每夜測試&lt;/li&gt;&lt;li&gt;里程碑測試&lt;/li&gt;&lt;li&gt;內部迭代至少一次&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;測試時間&lt;/li&gt;&lt;li&gt;運行方式&lt;ul&gt;&lt;li&gt;手動/半自動化(需要一定程度手動)/自動化&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;描述&lt;ul&gt;&lt;li&gt;測試目的&lt;ul&gt;&lt;li&gt;到底要驗證什麼&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;初始條件和背景&lt;ul&gt;&lt;li&gt;確定那些條件是重要的先決條件&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;步驟(測試點 Test Point)        1.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;    2.&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;    3.
-   預期結果
    -   通過 Pass
    -   受一個具體的檢查點 checkpoint 規範
-   備註&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;自動化測試&quot;&gt;&lt;/a&gt;自動化測試&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;設置 Setup&lt;ul&gt;&lt;li&gt;將環境設定好&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;執行 Execution&lt;ul&gt;&lt;li&gt;執行測試的特定步驟,充分錯誤處理,其他相關工作&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;分析 Analysis&lt;ul&gt;&lt;li&gt;分析為什麼失敗&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;報告 Reporting&lt;ul&gt;&lt;li&gt;報告包含日誌/資料庫/其他分析結果文件&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;清理 Cleanup&lt;ul&gt;&lt;li&gt;清理當前環境狀態已讓下次繼續進行&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;幫助 Help&lt;ul&gt;&lt;li&gt;在其測試生命週期如何保持可維護性&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;測試日誌應該包含的元素&lt;ul&gt;&lt;li&gt;測試ID Test ID&lt;/li&gt;&lt;li&gt;測試名稱 Test Name&lt;/li&gt;&lt;li&gt;環境訊息 Environment Information&lt;/li&gt;&lt;li&gt;被測程式訊息 Application Under Test Information AUT Info&lt;/li&gt;&lt;li&gt;測試結果 Test Result&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;測試結果的分類&lt;ul&gt;&lt;li&gt;通過 Pass&lt;/li&gt;&lt;li&gt;失敗 Fail&lt;/li&gt;&lt;li&gt;跳過 SKip 跳過環境不支援的特定測試&lt;/li&gt;&lt;li&gt;放棄 Abort 測試失效時就直接放棄&lt;/li&gt;&lt;li&gt;阻斷 Block 被阻止不會讓測試失敗率更加增高&lt;/li&gt;&lt;li&gt;警告 Warn 雖然通過了旦指出需要更細緻檢查某些地方&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;其他工具&quot;&gt;&lt;/a&gt;其他工具&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;churn 改動: 在一段時間內, 文件和模塊被修改的次數&lt;ul&gt;&lt;li&gt;也就是被改動的次數&lt;ul&gt;&lt;li&gt;修改次數&lt;/li&gt;&lt;li&gt;增加行數&lt;/li&gt;&lt;li&gt;刪除行數&lt;/li&gt;&lt;li&gt;修改行數&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Total churn 可以顯示出在哪個地方可能有最多潛在 bug&lt;/li&gt;&lt;li&gt;驗收測試 BATs Build acceptance tests/ BVTs Build verification tests&lt;/li&gt;&lt;li&gt;應該每天或更頻繁的 Build&lt;ul&gt;&lt;li&gt;rolling builds 滾動構建&lt;/li&gt;&lt;li&gt;自動同步到最新的 code&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;BATs 比 BVT 範圍小一點&lt;/li&gt;&lt;li&gt;BVT 屬性&lt;ul&gt;&lt;li&gt;Automate Everything (在每次 Build 前運行)&lt;/li&gt;&lt;li&gt;Test a little (驗證基本功能的簡單測試, 確保構建可被用於測試)&lt;/li&gt;&lt;li&gt;Test Fast (要求快速幾分鐘測試, 快速給予反饋)&lt;/li&gt;&lt;li&gt;Fail Perfectly 如果 BVT 失敗要立即修復失敗的地方&lt;/li&gt;&lt;li&gt;Test Broadly not Deeply 盡可能多涵蓋關鍵功能&lt;/li&gt;&lt;li&gt;Debuggable and Maintainable (BVT 會自動到 code 裡面找哪個change造成)&lt;/li&gt;&lt;li&gt;Trustworthy 可信 (要能信任 BVT 通過)&lt;/li&gt;&lt;li&gt;Critical 關鍵 (BVT 應該由最值得信賴的人建立)&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;程式碼分析成本 Code Analysis Overload&lt;ul&gt;&lt;li&gt;全新項目早期分析的缺陷幾乎注意不到&lt;/li&gt;&lt;li&gt;成熟階段使用帶來額外工作量&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;後記&quot;&gt;&lt;/a&gt;後記&lt;/h2&gt;&lt;p&gt;花一個晚上看完，覺得收穫良多，裡面還有推薦很多參考書籍，未來可以看看&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;buzz&amp;#95;word&quot;&gt;&lt;/a&gt;Buzz Word&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;TTM ( Time to market ) 產品從構思到銷售的總時間&lt;/li&gt;&lt;li&gt;assign 指派修正&lt;/li&gt;&lt;li&gt;postpone 推辭處理 -&gt; 技術負債&lt;/li&gt;&lt;li&gt;不要聽河馬的&lt;ul&gt;&lt;li&gt;河馬 HiPPO ( Highest Paid Person's Opinion ) 指最高薪資的人&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;BDUF - Big Design Up Front 指各種費時的預先設計和撰寫文件的動作&lt;/li&gt;&lt;li&gt;look and feel 外再體驗&lt;/li&gt;&lt;/ul&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 13 Feb 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-02-13-Emacs-中透過-which-function-mode-取得當前游標所在的函數名稱/
</guid>
<link>
http://lisp.rocks/posts-output/2018-02-13-Emacs-中透過-which-function-mode-取得當前游標所在的函數名稱/
</link>
<title>
Emacs 中透過 (which-function) 取得當前函數名稱
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href='https://www.emacswiki.org/emacs/WhichFuncMode'&gt;Which Func Mode&lt;/a&gt; 是在 Emacs 中他可以自動幫你對應找出當前游標目前處在的函數名稱&lt;/p&gt;&lt;p&gt;他支援多數主要的語言，中文可見 &lt;a href='https://github.com/emacs-china/hello-emacs/blob/master/Emacs_Redux/which-function-mode.org'&gt;Emacs-China 的 hello-emacs 中的說明&lt;/a&gt;&lt;/p&gt;&lt;p&gt;其實很簡單，就是透過 &lt;code&gt;&amp;#40;which-function&amp;#41;&lt;/code&gt; 即可使用&lt;/p&gt;&lt;p&gt;唯一需要留意的事情，如果你要在自己的 code 裡面使用&lt;/p&gt;&lt;p&gt;你可能有 &lt;code&gt;&amp;#40;which-function-mode&amp;#41;&lt;/code&gt; 的函數但沒有啟用 &lt;code&gt;&amp;#40;which-function&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;所以要記得 &lt;code&gt;&amp;#40;require 'which-func&amp;#41;&lt;/code&gt; 來讀取，否則你無法調用函數&lt;/p&gt;&lt;p&gt;此外 &lt;code&gt;&amp;#40;which-function&amp;#41;&lt;/code&gt; 也不是 &lt;code&gt;interactive&lt;/code&gt; 的函數，所以可以自己包一成&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;require 'which-func&amp;#41;
&amp;#40;defun show-which-function &amp;#40;&amp;#41;
  &amp;#40;interactive&amp;#41;
  &amp;#40;setq which-function-mode t&amp;#41;
  &amp;#40;which-function&amp;#41;
  &amp;#40;setq which-function-mode nil&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;應該是 Emacs 原生套件，還不錯用&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 13 Feb 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-02-13-Emacs 中對目錄中所有檔案執行相同操作/
</guid>
<link>
http://lisp.rocks/posts-output/2018-02-13-Emacs 中對目錄中所有檔案執行相同操作/
</link>
<title>
Emacs 中對目錄中所有檔案執行相同操作
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在 Emacs 中如果要對所有檔案做相同的操作，例如對所有檔案找出 &lt;code&gt;TODO&lt;/code&gt; 在第幾行&lt;/p&gt;&lt;p&gt;並丟到 Message 中的話，可以使用 &lt;code&gt;&amp;#40;directory-files-recursively&amp;#41;&lt;/code&gt; 和 &lt;code&gt;&amp;#40;mapcar&amp;#41;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;並透過 projectile 來在專案目錄下執行&lt;/p&gt;&lt;p&gt;假設我有一個自訂的搜尋方法叫做 &lt;code&gt;my-search&lt;/code&gt; 那麼我可以這樣&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defun search-all &amp;#40;&amp;#41;
  &amp;#40;interactive&amp;#41;
  &amp;#40;mapcar 'my-search
    &amp;#40;directory-files-recursively
      &amp;#40;projectile-project-root&amp;#41; &amp;quot;.py$&amp;quot;&amp;#41;&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;透過指定副檔名結尾來對所有同樣類型的檔案進行特定函數的操作&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 13 Feb 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-02-01-嘗試使用-PyQt5/
</guid>
<link>
http://lisp.rocks/posts-output/2018-02-01-嘗試使用-PyQt5/
</link>
<title>
嘗試使用 PyQt5
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;原先就想精進 C++ 和 Python 而最近買了書 &lt;a href='https://www.tenlong.com.tw/products/9787302415879'&gt;Python 項目開發實戰&lt;/a&gt;&lt;/p&gt;&lt;p&gt;裡面再介紹怎麼做一個桌面應用專案，介紹到了 PyQt 所以就想說來嘗試看看&lt;/p&gt;&lt;p&gt;為了避免未來忘記，在此僅做一點初步的紀錄&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;安裝&quot;&gt;&lt;/a&gt;安裝&lt;/h2&gt;&lt;p&gt;使用 Python 3 的話就可以直接透過 &lt;code&gt;pypi&lt;/code&gt; 安裝 PyQt5&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pypi install pyqt5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安裝完之後建立一個初步的 APP 參考如下&lt;/p&gt;&lt;pre&gt;&lt;code&gt;import sys
from PyQt5.QtWidgets import QApplication, QWidget&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;class MainWindow&amp;#40;QWidget&amp;#41;:
    def &amp;#95;&amp;#95;init&amp;#95;&amp;#95;&amp;#40;self&amp;#41;:
        super&amp;#40;self.&amp;#95;&amp;#95;class&amp;#95;&amp;#95;, self&amp;#41;.&amp;#95;&amp;#95;init&amp;#95;&amp;#95;&amp;#40;&amp;#41;
        self.setupUi&amp;#40;&amp;#41;
        self.show&amp;#40;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;    def setupUi&amp;#40;self&amp;#41;:
        self.setWindowTitle&amp;#40;&amp;quot;Hello World!&amp;quot;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;if &amp;#95;&amp;#95;name&amp;#95;&amp;#95; == &amp;quot;&amp;#95;&amp;#95;main&amp;#95;&amp;#95;&amp;quot;:
    app = QApplication&amp;#40;sys.argv&amp;#41;
    MainWindow = MainWindow&amp;#40;&amp;#41;
    sys.exit&amp;#40;app.exec&amp;#95;&amp;#40;&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;執行效果如下&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/pyqt-hello-world.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 01 Feb 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-27-Producing-Open-Source-Software-閱讀筆記/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-27-Producing-Open-Source-Software-閱讀筆記/
</link>
<title>
〈 Producing Open Source Software 〉閱讀筆記 1
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;因為想了解 Open Source 的一些經營和法律問題，所以找了這本書來讀。&lt;/p&gt;&lt;p&gt;針對裡面的一些重點作筆記，主要還是會偏向對開源專案的看法，一般性的討論就比較少。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;怎樣判斷一個專案的失敗？&quot;&gt;&lt;/a&gt;怎樣判斷一個專案的失敗？&lt;/h2&gt;&lt;p&gt;本書作者首先從如何判斷開源專案破題：&lt;/p&gt;&lt;p&gt;我們一般都不會聽到 Open Source 失敗，大部分就是維護者離開而停止維護&lt;/p&gt;&lt;p&gt;而這個離開是漸漸地，甚至是以另開一個新項目的方式結束，&lt;/p&gt;&lt;p&gt;又或是可以用專案使用的人漸漸變少來判斷呢？這些都顯示判斷一個專案結束很困難&lt;/p&gt;&lt;p&gt;而作者在本書中，想嘗試的就是告知讀者如何「避免專案失敗」&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;最常見錯誤：過高的期待&quot;&gt;&lt;/a&gt;最常見錯誤：過高的期待&lt;/h2&gt;&lt;p&gt;作者提到最常見對開源專案的誤解，就是抱有不切實際的期待&lt;/p&gt;&lt;p&gt;所以專案負責人可能不會投入過多的時間在介紹專案和包裝，把這些視為次要的&lt;/p&gt;&lt;p&gt;然而對於不熟悉的人，這些都很重要，但工程師也無可厚非，他們擅長他們擅長的事情&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;專案管理幾乎不太必要&quot;&gt;&lt;/a&gt;專案管理幾乎不太必要&lt;/h2&gt;&lt;p&gt;在一個成功的開源專案中，很多討論和決定都是在檯面下進行&lt;/p&gt;&lt;p&gt;因為專案的組成成員是隨機而來，大家又幾乎沒有見過面，所以很難思考這個情況下會發生什麼事情&lt;/p&gt;&lt;p&gt;專案管理人們可能會相對活躍，但也是以低調和非正式的方式進行&lt;/p&gt;&lt;p&gt;因此多數管理的目標主要就是確定彼此有共同的看法，並設定溝通的規範&lt;/p&gt;&lt;p&gt;確保不會有人被排擠，並且可以讓專案成為貢獻者經常回來的地方&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;失敗的文化建設&quot;&gt;&lt;/a&gt;失敗的文化建設&lt;/h2&gt;&lt;p&gt;大多數好的專案都會顯示出來他們獎勵、或是懲罰什麼樣的行為&lt;/p&gt;&lt;p&gt;通常專案會鼓勵不再規劃中的事件發生，儘管需要犧牲一些協調溝通的代價&lt;/p&gt;&lt;p&gt;而長期參與者會內化一個標準，使其成為一個貢獻者們共通的大致共識&lt;/p&gt;&lt;p&gt;而不成功的專案通常就是偏離了這個核心文化&lt;/p&gt;&lt;p&gt;使得專案遇到問題時，會突然迅速造成結果惡化，因為貢獻者們沒有對問題有共通的共識來解決分歧&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;開源是選擇性文化&quot;&gt;&lt;/a&gt;開源是選擇性文化&lt;/h2&gt;&lt;p&gt;所有人會參與到一個專案中，是因為他們選擇參與，如果他們不喜歡就會離開&lt;/p&gt;&lt;p&gt;只要他們喜歡就會付出一些時間，但要形成一個具有凝聚力和專注的團隊需要很長時間&lt;/p&gt;&lt;p&gt;同時要失去一個潛在有興趣的人，是很容易的一件事情，例如差勁的第一印象，別人就不會給予第二次機會&lt;/p&gt;&lt;p&gt;要維持這樣的聯繫很不容易，本書給予了一個很好的評量標準：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;「參與者必須感受到他們與開源專案的聯繫，以及對專案的影響和他們的貢獻是成正比。」&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;選擇的技術框架、宣傳模式以及開發語言，都會影響到這一切&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;兩類不同的專案訪問對象：使用者和開發人員&quot;&gt;&lt;/a&gt;兩類不同的專案訪問對象：使用者和開發人員&lt;/h2&gt;&lt;p&gt;有必須要思考哪些是使用者和開發人員共同都需要知道的，而那些要分開來&lt;/p&gt;&lt;p&gt;使用者文件和開發文件是否提供對應合適的訊息&lt;/p&gt;&lt;p&gt;如何讓用戶和開發人員放心？願意提出問題，甚至參與到專案中&lt;/p&gt;&lt;p&gt;關鍵就是要讓使用者和開發人員都要感受到：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;「如果你插手這個專案，你不會浪費你的時間。」&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;是否重新發明了輪子&quot;&gt;&lt;/a&gt;是否重新發明了輪子&lt;/h2&gt;&lt;p&gt;首先應該到各大開源專案平台搜尋，是否有和你類似的專案已經出現&lt;/p&gt;&lt;p&gt;如果有你還是想做，為了累積更多經驗的話也是無訪&lt;/p&gt;&lt;p&gt;甚至說你想對該現有專案做更深入的專業化，而別人可能做不到&lt;/p&gt;&lt;p&gt;通常這些想法都可以接受，但是你可能會發現加入這些項目比從頭開始更好&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;專案的最低激發能量：讓新人擺脫初始的陌生障礙&quot;&gt;&lt;/a&gt;專案的最低激發能量：讓新人擺脫初始的陌生障礙&lt;/h2&gt;&lt;p&gt;一個專案的開始，很重要就是要讓新人能快速擺脫不熟悉且陌生的初始狀況&lt;/p&gt;&lt;p&gt;這是一個專案最低的基本門檻，有人把這個門檻稱作「hacktivation energy」&lt;/p&gt;&lt;p&gt;也就是新人能在回頭來到你專案之前，他被鼓勵到能參與多深的水平&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;參考資料&quot;&gt;&lt;/a&gt;參考資料&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href='https://www.amazon.com/Producing-Open-Source-Software-Successful/dp/0596007590'&gt;Producing Open Source Software: How to Run a Successful Free Software Project | Amazon.com Books&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 27 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-27-Producing-Open-Source-Software-閱讀筆記-2/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-27-Producing-Open-Source-Software-閱讀筆記-2/
</link>
<title>
〈 Producing Open Source Software 〉閱讀筆記 2
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;為專案選好名字&quot;&gt;&lt;/a&gt;為專案選好名字&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;盡可能好記，也就是以英文好發音&lt;/li&gt;&lt;li&gt;可使用雙關語，如果有能聯想到專案內容的連結的話&lt;/li&gt;&lt;li&gt;可以盡量不要重複&lt;/li&gt;&lt;li&gt;如果有對應的頂級網域就更好&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;清楚的使命聲明&amp;#95;(&amp;#95;mission&amp;#95;statement&amp;#95;)&quot;&gt;&lt;/a&gt;清楚的使命聲明 ( Mission Statement )&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;如何讓使用者在 30 秒內明白專案內容並引起他們的興趣&lt;/li&gt;&lt;li&gt;通常在首頁或是專案名稱正下方&lt;/li&gt;&lt;li&gt;應該是具體的、限制性、簡短的描述&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;聲稱為開源專案&quot;&gt;&lt;/a&gt;聲稱為開源專案&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;很多專案都是在下載才列出來&lt;/li&gt;&lt;li&gt;甚至沒有選擇許可證&lt;/li&gt;&lt;li&gt;應該在專案敘述中強調這件事情並給出確切許可證&lt;/li&gt;&lt;li&gt;也可以另外開啟一個文件版面說明專案版權選擇細節&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;列出專案功能與需求&amp;#95;(&amp;#95;features&amp;#95;and&amp;#95;requirements&amp;#95;list&amp;#95;)&quot;&gt;&lt;/a&gt;列出專案功能與需求 ( Features and Requirements List )&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;在快速看過這些專案後，通常訪問對象會有 5 分鐘深入了解細節&lt;/li&gt;&lt;li&gt;這時候應該要說明專案支持的功能&lt;/li&gt;&lt;li&gt;如果尚未完成他，可以加註 (in progress) 或 (planned)&lt;/li&gt;&lt;li&gt;同時要說明運行你的專案需要的開發或運行環境需求&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Features:&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;  - XXXXX&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;  - &amp;#40;planned&amp;#41; XXXXX&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;Requirements:&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;  - Python a.b or higher&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;看完這些能使讀者快速判斷他是否能使用或參與你的專案&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;說明開發狀況&amp;#95;(&amp;#95;development&amp;#95;status&amp;#95;)&quot;&gt;&lt;/a&gt;說明開發狀況 ( Development Status )&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;讀者同時也會想知道你對專案的承諾是否有具體實現&lt;/li&gt;&lt;li&gt;對於成熟的專案，大家想知道專案的維護模式如何進行、新版本的發行頻率、錯誤報告的修正速度&lt;/li&gt;&lt;li&gt;為了要回答這些問題，要有一個提說明開發狀況的頁面&lt;/li&gt;&lt;li&gt;並且列出專案的目標以及近期專案開發上需要協助的地方&lt;/li&gt;&lt;li&gt;也可以說明歷史版本記錄，以及功能列表&lt;/li&gt;&lt;li&gt;不要怕告知專案目前的缺陷，如果讓使用者誤以為沒有缺陷是很糟糕的事情&lt;/li&gt;&lt;li&gt;長遠來看保守一些是好事，如果能比讀者認為的穩定得多自然而然會有口碑&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;提供下載&amp;#95;(&amp;#95;downloads&amp;#95;)&quot;&gt;&lt;/a&gt;提供下載 ( Downloads )&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;對於很多潛在的專案成員來說，安裝失敗是最挫折的事情&lt;/li&gt;&lt;li&gt;最好讓發行的機制盡量方便、標準化且低成本&lt;/li&gt;&lt;li&gt;最好有標準的安裝流程，並且不要偏離太多&lt;/li&gt;&lt;li&gt;提供執行檔可能初期還不太必要，除非有針對特別普通使用者做簡單發行版本&lt;/li&gt;&lt;li&gt;要有一個唯一的版本號，這樣使用者才能去比較不同的版本的差異&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;版本控制與議題追蹤&quot;&gt;&lt;/a&gt;版本控制與議題追蹤&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;比較熟悉就不記了&amp;#x2026;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;溝通管道&quot;&gt;&lt;/a&gt;溝通管道&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;很多參與者不一定想投入到專案中，但樂於追蹤最新消息&lt;/li&gt;&lt;li&gt;專案早期可能有更高比例的開發人員而非使用者，或是兩者相當模糊&lt;/li&gt;&lt;li&gt;如何平衡兩者的溝通管道很重要，並且不會造成大家反感或覺得太多灌水&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;開發者指南&amp;#95;developer&amp;#95;guidelines&quot;&gt;&lt;/a&gt;開發者指南 Developer Guidelines&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;如果有人想參與的專案中，可能會想要有一個開發者指南&lt;/li&gt;&lt;li&gt;開發者指南通常不是太技術性，而是單純解釋了開發者如何與用戶互動和完成工作&lt;/li&gt;&lt;li&gt;通常包含幾個資訊：&lt;ul&gt;&lt;li&gt;說明能和其他貢獻者溝通交流的平台在哪裡&lt;/li&gt;&lt;li&gt;如果有錯誤要報告或是想提交 Patch 怎麼做&lt;/li&gt;&lt;li&gt;可以參考 &lt;a href='http://www.openoffice.org/dev_docs/guidelines.html'&gt;OpenOffice.org - Guidelines&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;撰寫文件&quot;&gt;&lt;/a&gt;撰寫文件&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;剛開始一個專案時，最好限制文件的範圍，否則很難逐步完成&lt;/li&gt;&lt;li&gt;一個好的基本文件要包含：&lt;ul&gt;&lt;li&gt;告訴讀者他需要的技術水平，並會學習到什麼&lt;/li&gt;&lt;li&gt;清楚的使用和設置說明，並且告訴使用者如何檢查他正確的設置完成（例如跑個 demo code）&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;給予一個簡單的教程，使得人們不會過早放棄&lt;/li&gt;&lt;li&gt;對於尚未完成的文件區塊可以打上未完成標籤，甚至鼓勵大家參與來撰寫&lt;/li&gt;&lt;li&gt;不要過分強調專案的缺點，專案剛開始有很多缺點很正常，關鍵時刻做說明即可&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;維護&amp;#95;faq&quot;&gt;&lt;/a&gt;維護 FAQ&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;最基本的溝通工具&quot;&gt;&lt;/a&gt;最基本的溝通工具&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;網站&lt;/li&gt;&lt;li&gt;郵件列表 Mailing list&lt;/li&gt;&lt;li&gt;議題追蹤 Bug tracking&lt;/li&gt;&lt;li&gt;實時討論 Real-time chat&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;#x2026;&lt;/p&gt;&lt;p&gt;有點累了&amp;#x2026; 剩下我先看完在做筆記吧！&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 27 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-25-Emacs-中使用-gnus-的基本快捷鍵/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-25-Emacs-中使用-gnus-的基本快捷鍵/
</link>
<title>
Emacs 中使用 gnus 的基本快捷鍵
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;最近使用 gnus 管理 Email 但是都搞不太懂他的快捷鍵&lt;/p&gt;&lt;p&gt;網路找了一些資料，整理自己常用的快捷鍵按鈕&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;Z C&lt;/code&gt; 標記所有文章為已讀&lt;/li&gt;&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 回信， &lt;code&gt;R&lt;/code&gt; 帶原文的回信&lt;/li&gt;&lt;li&gt;&lt;code&gt;L&lt;/code&gt; 顯示 0 郵件的分類 &lt;code&gt;l&lt;/code&gt; 只顯示有未讀的群組&lt;/li&gt;&lt;li&gt;&lt;code&gt;g&lt;/code&gt; 重新整理並取得最新郵件&lt;/li&gt;&lt;li&gt;&lt;code&gt;m&lt;/code&gt; 寫信 &lt;code&gt;C-c C-c&lt;/code&gt; 寄出 &lt;code&gt;C-x s&lt;/code&gt; 保存草稿 &lt;code&gt;C-c C-d&lt;/code&gt; 退出 &lt;code&gt;C-c C-k&lt;/code&gt; 強制退出&lt;/li&gt;&lt;li&gt;&lt;code&gt;C-c C-a&lt;/code&gt; 添加附件&lt;/li&gt;&lt;li&gt;&lt;code&gt;o / C-o&lt;/code&gt; 在郵件中保存附件&lt;/li&gt;&lt;li&gt;&lt;code&gt;B DEL&lt;/code&gt; 刪除郵件&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在 gnus 中對已讀和未讀的信有一些標記&lt;/p&gt;&lt;p&gt;例如已讀的信會有 &lt;code&gt;R, r, O, E&lt;/code&gt;&lt;/p&gt;&lt;p&gt;而未讀的信會有 &lt;code&gt;!, ?, &amp;#42;&lt;/code&gt; 的標記&lt;/p&gt;&lt;p&gt;其中&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;R&lt;/code&gt; 表示這次閱讀過了&lt;/li&gt;&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 表示是手動 &lt;code&gt;d&lt;/code&gt; 打上已讀標籤的文章&lt;/li&gt;&lt;li&gt;&lt;code&gt;O&lt;/code&gt; 上次已經閱讀過了，默認不會出現除非使用 &lt;code&gt;/ o&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;!&lt;/code&gt; ticked 保留標記，保留可見，想持續追蹤&lt;/li&gt;&lt;li&gt;&lt;code&gt;?&lt;/code&gt; dormant 休眠標記，除非有人回應否則不會看到這個&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; 空格標記及表示仍然是未讀文章&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;#42;&amp;#42;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;參考資料&quot;&gt;&lt;/a&gt;參考資料&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href='http://www.junzilou.com/blog/emacs_gnus_shortcuts.html'&gt; emacs的gnus的一些快捷键 | 君子楼&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://www.ibm.com/developerworks/cn/linux/l-cn-emacsgnus/index.html'&gt;Emacs Gnus 的基本配置与使用&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 25 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-24-Emacs-中使用-wakatime-追蹤開發時間/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-24-Emacs-中使用-wakatime-追蹤開發時間/
</link>
<title>
Emacs 中使用 wakatime 追蹤開發時間
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;最近在使用 elfeed 的功能，就順道看了 Spacemacs 的其他 Web Services layer&lt;/p&gt;&lt;p&gt;然後想說慢慢來用看看，今天先嘗試的是 wakatime&lt;/p&gt;&lt;p&gt;簡單的介紹可以參考 &lt;a href='http://www.iamlj.com/2016/07/recommend-tools-wakatime/'&gt; WakaTime - 编程时间管理工具 顺便秀秀编程时间 | Jing’s Blog &lt;/a&gt;&lt;/p&gt;&lt;p&gt;在 windows 上面安裝需要留意一些事情&lt;/p&gt;&lt;p&gt;首先是要用 &lt;code&gt;Run as Administer&lt;/code&gt; 開啟 cmd&lt;/p&gt;&lt;p&gt;然後安裝&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pip install wakatime&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下來使用 Spacemacs 的說明中提到的設定&lt;/p&gt;&lt;pre&gt;&lt;code&gt;;; 在 dotspacemacs-configuration-layers 中新增
&amp;#40;wakatime :variables
                wakatime-api-key  &amp;quot;&amp;lt;註冊完帳號就會有API-KEY&amp;gt;&amp;quot;
                ;; use the actual wakatime path
                wakatime-cli-path &amp;quot;&amp;lt;可不填,只要python套件在環境變數中&amp;gt;&amp;quot;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這邊的 API-KEY 在註冊完畢 wakatime 就會得到，需要驗證 email&lt;/p&gt;&lt;p&gt;而 Path 的話則是不用輸入，因為在 Windows 上面處理 path 會很麻煩，有斜線問題&lt;/p&gt;&lt;p&gt;如果你的 python 安裝路徑本身就在環境路徑下，那就不用添加 path&lt;/p&gt;&lt;p&gt;如果你 wakatime 沒執行成功，他會在 Emacs 的 &lt;code&gt;&amp;#42;messages&amp;#42;&lt;/code&gt; buffer 告訴你他想執行的指令&lt;/p&gt;&lt;p&gt;像我剛改完畢 Spacemacs 設定，馬上就更新到 wakatime 網站了&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/waaktime-try.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;參考資料&quot;&gt;&lt;/a&gt;參考資料&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href='http://www.iamlj.com/2016/07/recommend-tools-wakatime/'&gt; WakaTime - 编程时间管理工具 顺便秀秀编程时间 | Jing’s Blog &lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Bweb-services/wakatime'&gt;spacemacs/layers/+web-services/wakatime at master · syl20bnr/spacemacs · GitHub&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 24 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-21-Emacs-中使用-elfeed-閱讀-RSS/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-21-Emacs-中使用-elfeed-閱讀-RSS/
</link>
<title>
Emacs 中使用 elfeed 閱讀 RSS
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;一直想從 feedly 搬到 Emacs 中，趁著有空來研究 elfeed&lt;/p&gt;&lt;p&gt;基本上在 Spacemacs 中預設就有 elfeed 以及用 org 管理 rss list 的 elfeed-org&lt;/p&gt;&lt;p&gt;我使用的方法是用 eval-after-load&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;eval-after-load 'elfeed
  &amp;#40;lambda &amp;#40;&amp;#41;
    &amp;#40;elfeed-org&amp;#41;
    &amp;#40;setq rmh-elfeed-org-files &amp;#40;list &amp;quot;&amp;#126;/.spacemacs.d/rss/elfeed.org&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後在你的 org 檔案裡面就可以依序放入 RSS list&lt;/p&gt;&lt;p&gt;例如（請把 &lt;code&gt;#&lt;/code&gt; 換成 &lt;code&gt;&amp;#42;&lt;/code&gt; ）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# Emacs                                                              :elfeed:
## http://ergoemacs.org/emacs/blog.xml
## http://planet.emacsen.org/atom.xml
## http://nullprogram.com/feed&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這邊要特別留意的是，第一個開頭一定要是 &lt;code&gt;&amp;#42; 某開頭          :elfeed:&lt;/code&gt; 這樣&lt;/p&gt;&lt;p&gt;這樣 elfeed 才會認知到你的 feed ，如果你在額外弄一個一級標題但沒有 &lt;code&gt;elfeed&lt;/code&gt; 的 tag&lt;/p&gt;&lt;p&gt;就不會被當作是 elfeed 的 feed ，記得使用 &lt;code&gt;C-c C-q&lt;/code&gt; 打上 tags&lt;/p&gt;&lt;p&gt;此外，如果不知道自己有沒有新增成功，可以透過指令 &lt;code&gt;elfeed-org-export-opml&lt;/code&gt; 來看&lt;/p&gt;&lt;p&gt;如果裡面沒有新增的 RSS，就代表你 org file 沒弄好&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;參考資料&quot;&gt;&lt;/a&gt;參考資料&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href='https://github.com/remyhonig/elfeed:'&gt;remyhonig/elfeed - An Emacs web feeds client&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/remyhonig/elfeed-org'&gt;remyhonig/elfeed-org - Configure the Elfeed RSS reader with an Orgmode file&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sun, 21 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-20-Wittgensteins-Remarks-on-the-Foundations-of-AI-第二章閱讀筆記/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-20-Wittgensteins-Remarks-on-the-Foundations-of-AI-第二章閱讀筆記/
</link>
<title>
Wittgenstein's Remarks on the Foundations of AI 第二章閱讀筆記
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;最近參與了本書 &lt;a href='https://www.amazon.com/Wittgensteins-Remarks-Foundations-Stuart-Shanker/dp/0415408571'&gt;Wittgenstein's Remarks on the Foundations of AI&lt;/a&gt; 的哲學讀書會&lt;/p&gt;&lt;p&gt;所以想說把一些筆記重點紀錄下來，在第二章大量討論人工智慧與規範性之間的關係&lt;/p&gt;&lt;p&gt;不理解規範性是什麼的話，本文很有可能看不懂，請留意&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;拆解「學習」這個概念&quot;&gt;&lt;/a&gt;拆解「學習」這個概念&lt;/h2&gt;&lt;p&gt;圖靈認為更高層次的學習概念，也可以拆解成更簡單的一些小概念連貫起來&lt;/p&gt;&lt;p&gt;這邊談的概念（ concept ）其實是一種「刺激」與「反映」的聯繫關係&lt;/p&gt;&lt;p&gt;因為對於普通人來說，我們講 &lt;strong&gt;X 具有 Y 概念&lt;/strong&gt; 其實往往是意味著 X 能做出某件關於 Y 概念的事情&lt;/p&gt;&lt;p&gt;也因此對於概念的掌握，其實是一種將概念視同一連串的等價反應（ equivaience response ）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;舉例來說，一個主體 S 如果能適當地回應 Φ 如何使用，並且掌握 Φ 的規則以及解釋 Φ 是什麼&lt;/p&gt;&lt;p&gt;那這樣我們會說主體 S 學習了關於 Φ 的概念&lt;/p&gt;&lt;p&gt;然而對於人工智慧系統來說，在回應、掌握和解釋上面，可能受到嚴重的限制&lt;/p&gt;&lt;p&gt;因此對於人工智慧來說，我們不應該說這樣的系統學習了什麼概念，而是要換一個講法&lt;/p&gt;&lt;p&gt;我們與其說人工智慧「學習了 X」，我們可能可以說他「有條件做 X」&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然而圖靈可能會認為，我們在思維上也很難區分這兩者，所以在行為上也很難分辨「學習了」和「有條件」的關係&lt;/p&gt;&lt;p&gt;真的很難區分嗎？實際上「有條件做」和「學習」之間有個因果關係程度上的差異&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;舉例來說，我們不一定要用因果關係的規範性術語，像是「有條件」這樣來描述學習&lt;/p&gt;&lt;p&gt;像是你學習說話，你很難說你從什麼時間點確切開始學習，觸發什麼條件才學習，然後到什麼時間點結束&lt;/p&gt;&lt;p&gt;但是掌握說話的相關概念是很重要的，也就是掌握說話的因果關係，在什麼樣前提條件下說什麼話&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;實踐的規範性：上升的複雜性&quot;&gt;&lt;/a&gt;實踐的規範性：上升的複雜性&lt;/h2&gt;&lt;p&gt;我們可以看到一個真正的「學習」案例，例如我們因為在學加法，學習了 1+1 = 2&lt;/p&gt;&lt;p&gt;然而這學習過程，會遮蔽掉我們去思考加法（+）的意思，這是因為我們要區分「加法」和「做加法」的差異&lt;/p&gt;&lt;p&gt;這種情況會造成「上升的複雜性」，在學習過程中為了區分，需要使用抽象概念暫時代替&lt;/p&gt;&lt;p&gt;也因此我們需要採取各種不同的規範實踐方法&lt;/p&gt;&lt;p&gt;使得我們最後把這個上升的複雜性的異質性降低到一個共同範式，也就是一個功能性的定義&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然而在圖靈，或是現在的人工智慧系統中，並沒有去掌握這樣的規範性&lt;/p&gt;&lt;p&gt;透過把學習拆解成一連串小部分的連續概念，只會導致破壞「學習」這個概念依賴的規範性基礎&lt;/p&gt;&lt;p&gt;這大概就是 2-3 的重點。&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;機器可以學會閱讀嗎？&quot;&gt;&lt;/a&gt;機器可以學會閱讀嗎？&lt;/h2&gt;&lt;p&gt;在 2-4 維根斯坦開始思考底下三者閱讀的差異：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;機械式地閱讀，想成人工智慧系統或機器的閱讀&lt;/li&gt;&lt;li&gt;普通人在不瞭解詞語的情況下閱讀&lt;/li&gt;&lt;li&gt;普通人正常的閱讀&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;維根斯坦指出，我們很難區分 2 和 3 ，例如政治家拿著演講稿照稿念、和小朋友正在開始學習閱讀&lt;/p&gt;&lt;p&gt;維根斯坦好奇的是 1 和 3 之間也有像似 2 和 3 之間的難以區分的情況嗎？&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;這邊比較機器閱讀和正常人閱讀，似乎只差在有沒有一個「意識」的感覺&lt;/p&gt;&lt;p&gt;看起來，機器和正常人都擁有「閱讀」的能力，都可以看著文章，然後機器可以烙印在他的狀態上面&lt;/p&gt;&lt;p&gt;而我們人可以將看到的視覺資訊透過神經系統轉換，然後透過大腦各種奇怪作用達到閱讀行為&lt;/p&gt;&lt;p&gt;看起來之間也有模糊地帶的樣子&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;然而維根斯坦更關心的事情是，在這種問題上面我們常常搞混「擁有（possession）」能力&lt;/p&gt;&lt;p&gt;和「行使（exercise）」能力之間的關係，前面那樣的定義，也緊緊是說明了「行使閱讀能力」層面的說明&lt;/p&gt;&lt;p&gt;但是對「擁有閱讀能力」層面，很明顯機器和人工智慧系統是有差異的&lt;/p&gt;&lt;p&gt;擁有閱讀能力更多的受到規範性影響，包含前面提到的「獲取知識」和「表現出像擁有知識」一樣&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 20 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-20-Emacs-中使用-popup-tip-彈出自訂內容/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-20-Emacs-中使用-popup-tip-彈出自訂內容/
</link>
<title>
Emacs 中使用 popup-tip 彈出自訂內容
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../../img/search-in-dict-example.gif&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;由於看到了 &lt;a href='http://blog.jenkster.com/2013/12/popup-help-in-emacs-lisp.html'&gt;Popup Help In Emacs Lisp&lt;/a&gt; 這篇文章，想要來自訂 popup-tip&lt;/p&gt;&lt;p&gt;其實函數十分簡單，文章的方法就夠用了，但我想要從自訂的檔案內容讀取出來&lt;/p&gt;&lt;p&gt;因為檔案可能搜尋不到，所以多了一行 message&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defun fatfingererr/coding-dict-at-point &amp;#40;&amp;#41;
  &amp;#40;interactive&amp;#41;
  &amp;#40;let&amp;#42; &amp;#40;&amp;#40;content &amp;#40;fatfingererr/search-in-dict
                   &amp;quot;coding&amp;quot; &amp;#40;thing-at-point 'word&amp;#41;&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;if content
        &amp;#40;popup-tip content
                   :point &amp;#40;point&amp;#41;
                   :around t
                   :height 30
                   :scroll-bar t
                   :margin t&amp;#41;
      &amp;#40;message &amp;quot;no match result...&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中因為我建立了一個字典資料夾，放在 &lt;code&gt;&amp;#126;/.spacemacs.d/dictionary&lt;/code&gt; 中&lt;/p&gt;&lt;p&gt;裡面我弄了一個 &lt;code&gt;coding&lt;/code&gt; 的資料夾，當作 coding 相關的字典檔案夾&lt;/p&gt;&lt;p&gt;也就是我只要目前游標停留在 &lt;code&gt;if&lt;/code&gt; 他就會去找 &lt;code&gt;&amp;#126;/.spacemacs.d/dictionary/coding/if&lt;/code&gt;&lt;/p&gt;&lt;p&gt;然後把檔案內容彈跳出來，例如一個提醒我寫 if 的內容：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# &amp;#126;/.spacemacs.d/dictionary/coding/if&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;【 if/else 條件語句 】&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;迴圈循環子可考慮寫成 club&amp;#95;i, members&amp;#95;i, users&amp;#95;i
或是 ci, mi, ui&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以我首先得先確定游標內容有沒有對應的檔案在字典資料夾裡面&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defun fatfingererr/search-in-dict-p &amp;#40;dict-name src&amp;#41;
  &amp;#40;if src &amp;#40;xah-string-match-in-list-p src
    &amp;#40;directory-files
     &amp;#40;expand-file-name dict-name my-dict-path&amp;#41;&amp;#41; nil&amp;#41;
  nil&amp;#41;
&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這邊我使用到 &lt;a href='http://ergoemacs.org/emacs/elisp_string_match_in_list.html'&gt;xah-string-match-in-list-p&lt;/a&gt; 函數，可以到連結裡面直接複製貼上&lt;/p&gt;&lt;p&gt;唯一要留意的就是使用這個函數，第三個參數要記得放，也就是 &lt;code&gt;match-case-p&lt;/code&gt;&lt;/p&gt;&lt;p&gt;接著我們確認完畢檔案存在，就開始把檔案內容讀出來&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defun fatfingererr/search-in-dict &amp;#40;dict-name src&amp;#41;
  &amp;#40;if &amp;#40;fatfingererr/search-in-dict-p dict-name src&amp;#41;
      &amp;#40;with-temp-buffer
      &amp;#40;insert-file-contents &amp;#40;expand-file-name
       &amp;#40;fatfingererr/search-in-dict-p dict-name src&amp;#41;
       &amp;#40;expand-file-name dict-name my-dict-path&amp;#41;&amp;#41;&amp;#41;
      &amp;#40;buffer-string&amp;#41;&amp;#41;
    nil&amp;#41;
  &amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;結果就會是像前面的 GIF 啦！還不錯！&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;參考資料&quot;&gt;&lt;/a&gt;參考資料&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href='http://blog.jenkster.com/2013/12/popup-help-in-emacs-lisp.html'&gt;Popup Help In Emacs Lisp&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 20 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-19-Windows中使用Rapid-Environment-Editor備份環境變數/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-19-Windows中使用Rapid-Environment-Editor備份環境變數/
</link>
<title>
使用 Rapid Environment Editor 備份環境變數
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;之前一直想要備份 Windows 的環境變數，然後找到一個好用的軟體 &lt;a href='https://www.rapidee.com/en/download'&gt;Rapid Environment Editor&lt;/a&gt;&lt;/p&gt;&lt;p&gt;這個軟體能備份和幫忙檢查有哪些環境變數是無效的&lt;/p&gt;&lt;p&gt;無效的環境變數會以紅色顯示，其中語言也有簡體中文版本，對 Windows 不熟也可以使用&lt;/p&gt;&lt;p&gt;所有變更只有在儲存之後才會真的變更，也不用擔心亂改改錯&lt;/p&gt;&lt;p&gt;備份的部分存成 &lt;code&gt;.reg&lt;/code&gt; 檔案，可以再把它讀取回來&lt;/p&gt;&lt;p&gt;內容就像是&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;; System variables
...
&amp;#91;HKEY&amp;#95;LOCAL&amp;#95;MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment&amp;#93;
&amp;quot;CCP&amp;#95;JOBTEMPLATE&amp;quot;=&amp;quot;Default&amp;quot;
&amp;quot;CCP&amp;#95;LOGROOT&amp;#95;USR&amp;quot;=hex&amp;#40;2&amp;#41;:25,4C,4F,43,41,4C,41,50,50,44,41,54,41,25,5C,4D,69,63,72,6F,73,6F,66,74,5C,48,70,63,5C,4C,6F,67,46,69,6C,65,73,5C,00
&amp;quot;ChocolateyInstall&amp;quot;=&amp;quot;C:\\ProgramData\\chocolatey&amp;quot;
&amp;quot;ComSpec&amp;quot;=hex&amp;#40;2&amp;#41;:25,53,79,73,74,65,6D,52,6F,6F,74,25,5C,73,79,73,74,65,6D,33,32,5C,63,6D,64,2E,65,78,65,00
&amp;quot;CUDA&amp;#95;PATH&amp;quot;=&amp;quot;C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v8.0&amp;quot;
&amp;quot;CUDA&amp;#95;PATH&amp;#95;V8&amp;#95;0&amp;quot;=&amp;quot;C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v8.0&amp;quot;
&amp;quot;DokanLibrary1&amp;quot;=&amp;quot;C:\\Program Files\\Dokan\\Dokan Library-1.0.0\\&amp;quot;
&amp;quot;GNUPLOT&amp;#95;LIB&amp;quot;=&amp;quot;C:\\Program Files\\gnuplot\\demo;C:\\Program Files\\gnuplot\\demo\\games;C:\\Program Files\\gnuplot\\share&amp;quot;
&amp;quot;GNUTERM&amp;quot;=&amp;quot;windows&amp;quot;
...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中蠻有趣的是部分會用 &lt;code&gt;hex&lt;/code&gt; 來表示，不知道那是什麼意思&amp;#x2026;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;參考資料&quot;&gt;&lt;/a&gt;參考資料&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href='http://nelson.pixnet.net/blog/post/22360384-%5B%E5%88%86%E4%BA%AB%5D-rapid-environment-editor&amp;mdash;%E6%96%B9%E4%BE%BF%E4%BF%AE%E6%94%B9%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8'&gt;{分享} Rapid Environment Editor - 方便修改環境變數的工具&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://dotblogs.com.tw/echo/2017/07/13/windows_tool_rapidenvironmenteditor'&gt;【Windows】環境變數管理工具：Rapid Environment Editor&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Fri, 19 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-17-〈為你自己學Git〉閱讀筆記/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-17-〈為你自己學Git〉閱讀筆記/
</link>
<title>
〈為你自己學Git〉閱讀筆記
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;對於 Git 還是始終不太熟悉，於是在朋友推薦下入手了這本書&lt;/p&gt;&lt;p&gt;原本想買另一本歐若禮更複雜更難那本，但先看完這本再說吧！&lt;/p&gt;&lt;p&gt;底下簡單留下自己的閱讀筆記，大部分應該都是網路找的到的指令&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;使用者設定&quot;&gt;&lt;/a&gt;使用者設定&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;# 設定
git config --global user.name &amp;quot;name&amp;quot;
git config --global user.email &amp;quot;email@mail.com&amp;quot;
# 檢視
git config --list
# local 不同作者
git config --local user.name &amp;quot;foo&amp;quot;
git config --local user.email &amp;quot;bar@foo.com&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;local 設定可以針對工作上切換成工作 Email ，在 global 方面就是 GitHub 帳戶&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;自訂縮寫&quot;&gt;&lt;/a&gt;自訂縮寫&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.st status&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以對附加參數做縮寫&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git config --global alias.l &amp;quot;log --oneline --graph&amp;quot;
git l # 等同 git log --oneline --graph 意思
# 也可以把 commit msg 包含進來
git config --global alias.ls 'log --graph --pretty=format:&amp;quot;%h &amp;lt;%an&amp;gt; %ar %s&amp;quot;'&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以直接在 &lt;code&gt;&amp;#126;/.gitconfig&lt;/code&gt; 修改&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#91;alias&amp;#93;
  co = checkout
  br = branch
  st = status
  l = log --oneline --graph
  ls log --graph --pretty=format=&amp;quot;%h &amp;lt;%an&amp;gt; %ar %s&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;commit&quot;&gt;&lt;/a&gt;commit&lt;/h2&gt;&lt;p&gt;懶惰單行 add + commit : &lt;code&gt;git commit -a -m &amp;quot;update content&amp;quot;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;查看&amp;#95;log&quot;&gt;&lt;/a&gt;查看 log&lt;/h2&gt;&lt;p&gt;只找某人的 log&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git log --oneline --author=&amp;quot;somebody&amp;quot;
# 查找兩人
git log --oneline --author=&amp;quot;someone/|anotherone&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用正則表達式搜尋&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git log --oneline --grep &amp;quot;wtf&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;搜尋哪些 commit 有用到這個字&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git log -S &amp;quot;someword&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查找時間&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git log --oneline --since=&amp;quot;9am&amp;quot; --until=&amp;quot;12am&amp;quot;
# 從特定日期起的指定時間
git log --oneline --since=&amp;quot;9am&amp;quot; --until=&amp;quot;12am&amp;quot; --after=&amp;quot;2017-01&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;修改&amp;#95;commit&amp;#95;紀錄&quot;&gt;&lt;/a&gt;修改 commit 紀錄&lt;/h2&gt;&lt;p&gt;修改最後一次的 commit message&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git commit --amend -m &amp;quot;new message&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;追加檔案到最新一次的 commit 中&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git add 某個檔案
git commit --amend --no-edit&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;對於空目錄可以放 palceholder 檔名可以叫做 &lt;code&gt;.gitkeep&lt;/code&gt; 或 &lt;code&gt;.keep&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;gitignore&quot;&gt;&lt;/a&gt;gitignore&lt;/h2&gt;&lt;p&gt;清除忽略的檔案，假如忽略的檔案是一些記錄或暫存檔案&lt;/p&gt;&lt;p&gt;使用指令 &lt;code&gt;git clean -fX&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;git&amp;#95;log&quot;&gt;&lt;/a&gt;git log&lt;/h2&gt;&lt;p&gt;看特定檔案的 commit 紀錄 &lt;code&gt;git log XXXXX.html&lt;/code&gt;&lt;/p&gt;&lt;p&gt;看檔案每一行是什麼時候被改的，抓兇手用的 &lt;code&gt;git blame XXXX.html&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;檔案刪除&quot;&gt;&lt;/a&gt;檔案刪除&lt;/h2&gt;&lt;p&gt;如果有檔案被刪除想找回來，可以使用 &lt;code&gt;checkout&lt;/code&gt; : &lt;code&gt;git checkout 被刪除檔案&lt;/code&gt;&lt;/p&gt;&lt;p&gt;如果想把所有刪除檔案找回來，可以使用 &lt;code&gt;git checkout .&lt;/code&gt;&lt;/p&gt;&lt;p&gt;如果要拿兩個版本之前的，可以使用 &lt;code&gt;git checkout HEAD&amp;#126;2 某個檔案&lt;/code&gt; 來使用&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;commit&amp;#95;後悔&quot;&gt;&lt;/a&gt;commit 後悔&lt;/h2&gt;&lt;p&gt;使用&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git reset master&amp;#94;
git reset HEAD&amp;#94;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;回到前一次 commit ，一個 &lt;code&gt;&amp;#94;&lt;/code&gt; 就代表往回一次，N 次可用 &lt;code&gt;&amp;#126;N&lt;/code&gt; 的方法&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;參考資料&quot;&gt;&lt;/a&gt;參考資料&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href='https://kaochenlong.com/2017/09/19/learn-git-for-your-own-good/'&gt;為你自己學 Git - 高見龍&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 17 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-17-Spacemacs快速查找layer的定義並修改/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-17-Spacemacs快速查找layer的定義並修改/
</link>
<title>
Spacemacs快速查找layer的定義並修改
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;為了解決 &lt;a href='https://emacs-china.org/t/topic/4353'&gt;Symbol’s function definition is void: org-projectile:per-repo&lt;/a&gt; 的問題&lt;/p&gt;&lt;p&gt;需要去到 &lt;code&gt;org-projectile&lt;/code&gt; 中修改套件的定義，使用到一個少用的功能，特此留作紀錄&lt;/p&gt;&lt;p&gt;也就是 key &lt;code&gt;M-m h SPC&lt;/code&gt; 可以快速查找目前載入的套件的 el 檔案&lt;/p&gt;&lt;p&gt;在本 bug 中需要到 &lt;code&gt;org-projectile&lt;/code&gt; 把 &lt;code&gt;&amp;#40;org-projectile&amp;#41;&lt;/code&gt; 註釋掉&lt;/p&gt;&lt;p&gt;進入檔案中透過 &lt;code&gt;C-s&lt;/code&gt; 搜尋修改即可&lt;/p&gt;&lt;p&gt;這樣就可以繼續使用 &lt;code&gt;org-capture &amp;#40;C-c c&amp;#41;&lt;/code&gt; 了!&lt;/p&gt;&lt;p&gt;此 bug 似乎是 &lt;code&gt;org-projectile&lt;/code&gt; 的問題，暫且不深究了&amp;#x2026;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 17 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-16-Emacs中使用eval-after-load避免使用尚未載入套件的函數/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-16-Emacs中使用eval-after-load避免使用尚未載入套件的函數/
</link>
<title>
Emacs中使用eval-after-load避免使用尚未載入套件的函數
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;今天因為要處理這個問題：&lt;/p&gt;&lt;p&gt;&lt;a href='https://github.com/syl20bnr/spacemacs/issues/9374'&gt;Symbol's function definition is void: org-projectile-per-project #9374&lt;/a&gt;&lt;/p&gt;&lt;p&gt;結果把 org-projectile 砍掉重新安裝&lt;/p&gt;&lt;p&gt;安裝的時候發現因為我定義的函數，有使用到 &lt;code&gt;projectile-project-root&lt;/code&gt; 但是套件又被我砍掉&lt;/p&gt;&lt;p&gt;結果就是安裝完套件我還是初始化失敗，因為我的 layer 使用到為定義的函數&lt;/p&gt;&lt;p&gt;因此安全起見，應該要把自訂函數有使用到套件功能的部分，在套件讀取後再定義&lt;/p&gt;&lt;p&gt;也就是要使用 &lt;code&gt;eval-after-load&lt;/code&gt; 的功能&lt;/p&gt;&lt;p&gt;使用方法如下，例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;eval-after-load 'org-projectile ;; 在讀取 org-projectile 後執行
  &amp;#40;progn
    ....
    ....
    &amp;#40;concat &amp;#40;projectile-project-root&amp;#41; .... &amp;#41; ;; 使用到 projectile-project-root
    ...
  &amp;#41;
&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以使用 &lt;code&gt;progn&lt;/code&gt; 指令組合多組語句，可以在其中 &lt;code&gt;defun&lt;/code&gt; 或 &lt;code&gt;define-key&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;參考資料&quot;&gt;&lt;/a&gt;參考資料&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href='http://emacser.com/eval-after-load.htm'&gt;用eval-after-load避免不必要的elisp包的加载&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 16 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-15-Windows中使用Spacemacs和clang-format/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-15-Windows中使用Spacemacs和clang-format/
</link>
<title>
Windows中使用Spacemacs和clang-format
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;目前對於 clang-format 還沒有很深刻的理解&lt;/p&gt;&lt;p&gt;簡單只是為了把 c++ code 對齊和整理&lt;/p&gt;&lt;p&gt;首先到 clang-format 網站去下載，搜尋 LLVM Download Page&lt;/p&gt;&lt;p&gt;下載位置: &lt;a href='http://releases.llvm.org/download.html'&gt;http://releases.llvm.org/download.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt; 點選 Pre-Built Binaries 中的 Clang for Windows (32-bits) 或 (64-bits)&lt;/p&gt;&lt;p&gt;其中 64-bit 網址在此 &lt;a href=&quot;http://releases.llvm.org/5.0.1/LLVM-5.0.1-win64.exe&quot;&gt;http://releases.llvm.org/5.0.1/LLVM-5.0.1-win64.exe&lt;/a&gt;&lt;/p&gt;&lt;p&gt;安裝完記得將 emacs 重新開啟，相關的 terminal 也要重開（才有新的環境變數 ）&lt;/p&gt;&lt;p&gt;接著在 spacemacs 中你引入 C/C++ 套件的位置改成&lt;/p&gt;&lt;pre&gt;&lt;code&gt;dotspacemacs-configuration-layers
'&amp;#40;
  ...
  &amp;#40;c-c++ :variables c-c++-enable-clang-support t&amp;#41; ;; 改成這樣
  ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;接著重新讀取，使用指令 &lt;code&gt;sync-configuration-layers&lt;/code&gt; 或是指令 &lt;code&gt;M-m f e R&lt;/code&gt;&lt;/p&gt;&lt;p&gt;並進入你的 c++ 檔案，使用 &lt;code&gt;clang-format-buffer&lt;/code&gt; 對整個 buffer 做 formatting&lt;/p&gt;&lt;p&gt;或是 &lt;code&gt;clang-format-region&lt;/code&gt; 對選取區域做 formatting&lt;/p&gt;&lt;p&gt;剛開始可以先使用 &lt;code&gt;clang-format-region&lt;/code&gt; 避免 buffer 檔案太大造成 Spacemacs 當機一會兒&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;使用&amp;#95;.clang-format&amp;#95;自訂設置&quot;&gt;&lt;/a&gt;使用 .clang-format 自訂設置&lt;/h2&gt;&lt;p&gt;如果你有使用 &lt;code&gt;projectile&lt;/code&gt; 的話，可以在你專案的根目錄（可以用 &lt;code&gt;prjectile-project-info&lt;/code&gt; 查看）&lt;/p&gt;&lt;p&gt;中新增檔案 &lt;code&gt;.clang-format&lt;/code&gt; 來設定你的 clang-format&lt;/p&gt;&lt;p&gt;沒使用 &lt;code&gt;projectile&lt;/code&gt; 則是得在檔案位置路徑有 &lt;code&gt;.clang-format&lt;/code&gt; 檔案&lt;/p&gt;&lt;p&gt;如果你不知道 clang-format 要設定什麼&lt;/p&gt;&lt;p&gt;可以先在 command-line 或是 Spacemacs 中使用 shell 執行&lt;/p&gt;&lt;pre&gt;&lt;code&gt;clang-format -style=llvm -dump-config &amp;gt; .clang-format&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;裡面影響比較大主要是行數限制，預設是 80 ，可以調整成 127 或更大&lt;/p&gt;&lt;p&gt;網路上寫 0 也沒用還是會算 80 我沒有試過&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ColumnLimit: 127&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;關於其他配置從 &lt;a href='https://github.com/leejayID/ClangFormat'&gt;代码格式化插件教程与配置&lt;/a&gt; 貼過來如下（只留下個人在意的部分）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# 基礎樣式
BasedOnStyle: LLVM
#
# 縮排寬度
IndentWidth: 4
#
# 大括號的換行模式&amp;#40;Attach，Stroustrup, Allman-所有大括號都換一行&amp;#41;
BreakBeforeBraces: Allman
#
# 是否支持單行的if
AllowShortIfStatementsOnASingleLine: false
#
# 是否允許單行迴圈
AllowShortLoopsOnASingleLine: false
#
# Switch 中的 Case 是否進行縮排
IndentCaseLabels: true
#
# 每行字元的位置，0 為不限制
ColumnLimit: 0
#
# 註釋對齊
AlignTrailingComments: true
#
# 括號後面加空格
SpaceAfterCStyleCast: true
#
# 不在小括號裡面加空格
SpacesInParentheses: false
#
# 不在中括號裡面加空格
SpacesInSquareBrackets: false
#
# 指針對準
DerivePointerAlignment: true
#
# @&amp;#91;&amp;#93;裡面兩邊的空格，預設為true
SpacesInContainerLiterals: false
#
# 賦值前&amp;#40;=&amp;#41;的空格 預設為true
SpaceBeforeAssignmentOperators: true
#
# 指針的位置
PointerAlignment: Right
#
# 最大空的行數
MaxEmptyLinesToKeep: 1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;參考資料&quot;&gt;&lt;/a&gt;參考資料&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href='http://shoshino21.logdown.com/posts/448026-currently-in-clang-format-format'&gt;目前在用的 clang-format 格式 - 星野的 iOS 補(不)完計畫&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/leejayID/ClangFormat'&gt;代码格式化插件教程与配置 - leejayID/ClangFormat&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 15 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-04-Emacs-中清除游標後空白直到非空白字元/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-04-Emacs-中清除游標後空白直到非空白字元/
</link>
<title>
Emacs 中清除游標後空白直到非空白字元
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;經常在打 code 時會遇到段落間，或是單行間因為修改而出現的大量空白&lt;/p&gt;&lt;p&gt;例如&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// a 和 10 之間有大量空白
int a  =                        10 ;
//       &amp;#94;&amp;#126;&amp;#126;&amp;#126; 假設游標停在這&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這時候可以讓游標停在 &lt;code&gt;=&lt;/code&gt; 後面，然後執行指令 &lt;code&gt;fixup-whitespace&lt;/code&gt; 即可&lt;/p&gt;&lt;p&gt;就會得到&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int a  = 10 ;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;還有許多行中空白、換行以及縮進的操作，請看 &lt;code&gt;simple.el&lt;/code&gt; 檔案&lt;/p&gt;&lt;p&gt;可以透過 &lt;code&gt;C-h f&lt;/code&gt; 搜尋 &lt;code&gt;fixup-whitespace&lt;/code&gt; 進入到 &lt;code&gt;simple.el&lt;/code&gt; 中&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 04 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-03-Emacs-中透過指令建立-read-only-buffer/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-03-Emacs-中透過指令建立-read-only-buffer/
</link>
<title>
Emacs 中透過指令建立 read-only buffer
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;有時候執行一些指令希望把結果訊息用 popup-window 顯示出來&lt;/p&gt;&lt;p&gt;這時候可以透過 insert 訊息到 buffer 之後轉 special-mode&lt;/p&gt;&lt;p&gt;這樣看完就可以透過 &lt;code&gt;q&lt;/code&gt; 退出 buffer 回到原本的 buffer&lt;/p&gt;&lt;p&gt;假設我們要 insert 紀錄的 log 檔案的話，可以使用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;let &amp;#40;&amp;#40;new &amp;#40;get-buffer-create 暫時的buffer名稱&amp;#41;&amp;#41;
      &amp;#40;current &amp;#40;current-buffer&amp;#41;&amp;#41;&amp;#41;
     &amp;#40;switch-to-buffer new&amp;#41;
     &amp;#40;insert-file-contents log檔案路徑&amp;#41;
     &amp;#40;special-mode&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;暫時的 buffer 名稱可以用 &lt;code&gt;&amp;#42;buffer-name&amp;#42;&lt;/code&gt; 表示&lt;/p&gt;&lt;p&gt;在把資訊 insert 到 buffer 後，透過 &lt;code&gt;&amp;#40;special-mode&amp;#41;&lt;/code&gt; 轉成 read-only 即可&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;參考資料&quot;&gt;&lt;/a&gt;參考資料&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/34432246/how-to-read-contents-of-the-file-programmatically-in-emacs&quot;&gt;https://stackoverflow.com/questions/34432246/how-to-read-contents-of-the-file-programmatically-in-emacs&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 03 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-02-Emacs-中處理檔名與路徑問題/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-02-Emacs-中處理檔名與路徑問題/
</link>
<title>
Emacs 中處理檔名與路徑問題
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在 Emacs 中經常會處理檔案名稱和路徑的問題&lt;/p&gt;&lt;p&gt;可以使用 &lt;code&gt;default-directory&lt;/code&gt; 來得到包含目前路徑的位置，此為變數&lt;/p&gt;&lt;p&gt;要換成 windows 路徑可以用底下方法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;replace-regexp-in-string &amp;quot;\/&amp;quot; &amp;quot;\\\\&amp;quot; default-directory&amp;#41;
&amp;quot;c:\\Users\\ricky\\foo\\bar&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果只是要檔案名稱可以用 &lt;code&gt;&amp;#40;buffer-name&amp;#41;&lt;/code&gt; 留意請要加括號，這是函數&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;buffer-name&amp;#41;
&amp;quot;2018-01-02-Emacs-中處理檔名與路徑問題.org&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果是要檔案的完整路徑可以用 &lt;code&gt;&amp;#40;buffer-file-name&amp;#41;&lt;/code&gt; 一樣要加括號&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;buffer-file-name&amp;#41;
&amp;quot;c:/Users/Ricky/lisp.rocks/resources/templates/org/posts/2018-01-02-Emacs-中處理檔名與路徑問題.org&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有時候在 Windows 中常常會遇到包含空白的檔案路徑，得用雙引號包住&lt;/p&gt;&lt;p&gt;在 Emacs 中得使用類似 &lt;code&gt;&amp;#40;concat &amp;quot;\&amp;quot;&amp;quot; some-path-include-space &amp;quot;\&amp;quot;&amp;quot;&amp;#41;&lt;/code&gt; 的方式處理&lt;/p&gt;&lt;p&gt;也就是說，雙引號得用 &lt;code&gt;\&amp;quot;&lt;/code&gt; 來表達才不會有錯誤&lt;/p&gt;&lt;p&gt;如果你想在當前游標位置插入路徑，可以用 &lt;code&gt;C-u C-x C-e&lt;/code&gt; 的方式對上面三者求值&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 02 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2018-01-01-Emacs-中對特定-mode-綁定特定的-imenu-關鍵字/
</guid>
<link>
http://lisp.rocks/posts-output/2018-01-01-Emacs-中對特定-mode-綁定特定的-imenu-關鍵字/
</link>
<title>
Emacs 中對特定 mode 綁定自訂 imenu 匹配
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在寫程式的時候大家或多或少都有自己的習慣&lt;/p&gt;&lt;p&gt;例如註解有些特殊寫法、或是控制流程和命名會有特殊的習慣&lt;/p&gt;&lt;p&gt;一般的 imenu 只能做到很細的在例如 if/else , for-loop , switch 間跳轉&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;如果要在一些註解、或是變數宣告間跳轉，這種比較高階的匹配可以自訂 imenu&lt;/p&gt;&lt;p&gt;只需要 hook 住特定 mode 就可以了&lt;/p&gt;&lt;p&gt;例如我想在 octave-mode (也就是 Matlab mode) 綁定基本控制流程可以用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;add-hook 'octave-mode-hook
          &amp;#40;lambda &amp;#40;&amp;#41;
            &amp;#40;setq imenu-generic-expression
                  '&amp;#40;&amp;#40;&amp;quot;for-loop&amp;quot; &amp;quot;&amp;#94;for &amp;#42;\\&amp;#40;.&amp;#42;\\&amp;#41;&amp;quot; 1&amp;#41;
                    &amp;#40;&amp;quot;if-else&amp;quot; &amp;quot;&amp;#94;if &amp;#42;\\&amp;#40;.&amp;#42;\\&amp;#41;&amp;quot; 1&amp;#41;
                    &amp;#40;&amp;quot;switch&amp;quot; &amp;quot;&amp;#94;switch &amp;#42;\\&amp;#40;.&amp;#42;\\&amp;#41;&amp;quot; 1&amp;#41;
                    &amp;#41;&amp;#41;&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;也就是說，通用的格式如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;add-hook '&amp;#91;某某-mode&amp;#93;-hook
          &amp;#40;lambda &amp;#40;&amp;#41;
            &amp;#40;setq imenu-generic-expression
                  '&amp;#40;&amp;#40;&amp;quot;&amp;#91;標題 1&amp;#93;&amp;quot; &amp;quot;&amp;#91;正則表達式 1&amp;#93;&amp;quot; 1&amp;#41;
                    &amp;#40;&amp;quot;&amp;#91;標題 2&amp;#93;&amp;quot; &amp;quot;&amp;#91;正則表達式 2&amp;#93;&amp;quot; 1&amp;#41;
                    &amp;#40;&amp;quot;&amp;#91;標題 3&amp;#93;&amp;quot; &amp;quot;&amp;#91;正則表達式 3&amp;#93;&amp;quot; 1&amp;#41;
                    &amp;#41;&amp;#41;&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果要更細緻地操作正則表達式，可以調整後面的數字來匹配 subexpression，基本可以用 1&lt;/p&gt;&lt;p&gt;如果要從頭匹配請用 &lt;code&gt;&amp;#94;&lt;/code&gt; 開頭，詳細請參考上方範例&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;參考資料&quot;&gt;&lt;/a&gt;參考資料&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='https://www.gnu.org/software/emacs/manual/html_node/elisp/Imenu.html'&gt;GNU Emacs - 22.5 Imenu&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 01 Jan 2018 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2017-12-30-C++API設計閱讀筆記/
</guid>
<link>
http://lisp.rocks/posts-output/2017-12-30-C++API設計閱讀筆記/
</link>
<title>
〈C++API設計〉閱讀筆記
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;最近讀完了 &lt;a href='http://www.books.com.tw/products/0010633959'&gt;C++ API設計&lt;/a&gt; 中文版，覺得裡面有很多觀念很不錯，都是自己缺乏的知識&lt;/p&gt;&lt;p&gt;因此稍微在此把各節大綱做個簡要筆記，留做未來工作上做參考&lt;/p&gt;&lt;p&gt;尤其這本書的目錄含蠻詳細的，光是目錄就能當作一個 Checklist 來使用了&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;目錄的重點摘要（非書籍目錄，有個人的更改）&quot;&gt;&lt;/a&gt;目錄的重點摘要（非書籍目錄，有個人的更改）&lt;/h3&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1 . 為什麼要使用 API&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;hr&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1-1. 可以有更健壯的程式碼&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1-1-1. 隱藏實作細節&lt;/p&gt;&lt;p&gt;1-1-2. 提高程式碼壽命&lt;/p&gt;&lt;p&gt;1-1-3. 促進模組化&lt;/p&gt;&lt;p&gt;1-1-4. 減少重複的程式碼&lt;/p&gt;&lt;p&gt;1-1-5. 移除硬編碼&lt;/p&gt;&lt;p&gt;1-1-6. 易於改變實作&lt;/p&gt;&lt;p&gt;1-1-7. 易於優化&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1-2. 可以提高程式碼重用性&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1-2-1. 更一般性的介面&lt;/p&gt;&lt;p&gt;1-2-2. 對於功能需求更深刻的了解&lt;/p&gt;&lt;p&gt;1-2-3. 顧及開發人員與客戶的共同利益&lt;/p&gt;&lt;p&gt;1-2-4. 全球化以及現代化的互相協作&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1-3. 對平行開發可以更友善&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1-3-1. 簡化關聯開發工作&lt;/p&gt;&lt;p&gt;1-3-2. 提供簡單實作以便編譯與連結&lt;/p&gt;&lt;p&gt;1-3-3. 提早撰寫單元測試&lt;/p&gt;&lt;p&gt;1-3-4. 獨立工作並減少冗餘溝通&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;2.&amp;#95;api&amp;#95;的基本品質&quot;&gt;&lt;/a&gt;2. API 的基本品質&lt;/h3&gt;&lt;p&gt;&lt;hr&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2-1. 問題領域塑模&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;2-1-1. 良好的抽象概念&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; 1.  高層次概念的明確表達 ( ex: UML ) &lt;/p&gt;&lt;p&gt; 2.  不公開底層的實作 &lt;/p&gt;&lt;p&gt; 3.  操作是有意義的（ 對非技術人員是顯而易見的 ） &lt;/p&gt;&lt;p&gt; 4.  類別反映了名稱及其方法 &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;2-1-2. 塑模關鍵物件 Object modeling&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; 1.  定義主要物件的集合 &lt;/p&gt;&lt;p&gt; 2.  提供所需的操作 &lt;/p&gt;&lt;p&gt; 3.  界定物件彼此的關係 &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;【 2-2. 隱藏實作細節 information hiding 】&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2-2-1. 物理隱藏：宣告與定義&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;2-2-1-1. 宣告 declaration 引入名稱和型別給編譯器，沒有分配記憶體&lt;/p&gt;&lt;pre&gt;&lt;code&gt;extern int i

class MyClass&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2-2-1-2. 定義 definition 提供型別結構的詳細資訊為變數分配記憶體&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int i = 0 ;

void MyFunc&amp;#40;int value&amp;#41;
{
 ...
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2-2-1-3. 一般來說在 .h 宣告，在 .cpp 定義&lt;/p&gt;&lt;p&gt;2-2-1-4. 在 .h 宣告且定義，會公開實作細節，是種不好的作法&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2-2-2. 邏輯隱藏：封裝 Encapsulation&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;2-2-2-1. 封裝的目的是限制其他物件存取權限&lt;/p&gt;&lt;p&gt;2-2-2-2. 封裝是將 API 公共介面和底層實作分開的過程&lt;/p&gt;&lt;p&gt;2-2-2-3. 若沒有好的封裝，高昂代價的重構（refactoring）將無可避免&lt;/p&gt;&lt;p&gt;2-2-2-4. 透過程式語言存取的特性，將 API 資訊隱藏到最高&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2-2-3. 隱藏成員變數&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;2-2-3-1. 封裝也可以是一種方法將資料操作方法的綁定&lt;/p&gt;&lt;p&gt;2-2-3-2. 良好的 API 永遠不公開成員變數&lt;/p&gt;&lt;p&gt;2-2-3-3. 資料成員成為 API 邏輯介面的話，應設定 getter / setter 間接存取&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; getter / setter 進行間接存取的好處： &lt;/p&gt;&lt;p&gt; 1 . &lt;strong&gt;驗證&lt;/strong&gt; ：對輸入輸出參數進行驗證再進行操作 &lt;/p&gt;&lt;p&gt; 2 . &lt;strong&gt;延遲運算&lt;/strong&gt; ：對成本高昂的運算做條件控制，不到非不得已不執行 ( lazy evaluation ) &lt;/p&gt;&lt;p&gt; 3 . &lt;strong&gt;快取&lt;/strong&gt; ：儲存需要經常使用的值，被要求時直接返值 ( caching ) &lt;/p&gt;&lt;p&gt; 4 . &lt;strong&gt;額外的運算&lt;/strong&gt; ：當被嘗試存取特定變數時，順便進行其他操作 &lt;/p&gt;&lt;p&gt; 例如 (a) 留下存取紀錄 (b) 修改對應檔案 &lt;/p&gt;&lt;p&gt; 5 . &lt;strong&gt;通知&lt;/strong&gt; ：某些物件可能需要監聽某個變數是否被改變， &lt;/p&gt;&lt;p&gt; 例如 (a) 控制變數（ ex: progress bar） (b) 發出修改通知 &lt;/p&gt;&lt;p&gt; 6 . &lt;strong&gt;除錯&lt;/strong&gt; ：可能想要增加日誌（ log ）語句，或是增加 Assert 語句來執行一些假設 &lt;/p&gt;&lt;p&gt; 7 . &lt;strong&gt;同步&lt;/strong&gt; ：每當有值被存取時加入互斥鎖定（mutex locking） &lt;/p&gt;&lt;p&gt; 8-1. &lt;strong&gt;更細的存取控制 1&lt;/strong&gt; ：讓成員變數變 public ，讓使用者可以寫入，唯一理由只有效能 &lt;/p&gt;&lt;p&gt; 例如：對大量物件執行一個效能緊迫的迴圈（直接存取 public 比 getter / setter 快 2-3 倍） &lt;/p&gt;&lt;p&gt; 8-2. &lt;strong&gt;更細的存取控制 2&lt;/strong&gt; ：不提供 setter 使得參數為 read-only &lt;/p&gt;&lt;p&gt; 9 . &lt;strong&gt;維持不變的關係&lt;/strong&gt; ：將內部資料值進行彼此依賴 &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;2-2-3-4. 資料成員應該總是被宣告為 private 而非 public 或 protected&lt;/p&gt;&lt;p&gt;2-2-3-5. 試著將 public 成員變數以 inline getter / setter 重寫並計時，看是否值得 public&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2-2-4. 隱藏實作方法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;2-2-4-1. 應該將類別穩定的介面和內部設計的實作分離&lt;/p&gt;&lt;p&gt;2-2-4-2. 切勿返回 private 成員變數的非 const 指標和參考，會破壞封裝&lt;/p&gt;&lt;p&gt;2-2-4-3. 採用 pimpl 慣用法，將實作細節完全隱藏&lt;/p&gt;&lt;p&gt;2-2-4-4. 如果不採用 pipml ，則可在 cpp 檔案中宣告 private 函式為 static ，而在表頭宣告為 private&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 30 Dec 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2017-12-28-WindowsBatch處理appendToFile的方法/
</guid>
<link>
http://lisp.rocks/posts-output/2017-12-28-WindowsBatch處理appendToFile的方法/
</link>
<title>
Windows batch 中處理 append file 的方法
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在 Windows 中如果要透過 batch 來 append file 有三種方法&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;單行&amp;#95;append&quot;&gt;&lt;/a&gt;單行 Append&lt;/h3&gt;&lt;p&gt;如果內容單行可以解決，可以透過 &lt;code&gt;&amp;gt;&amp;gt; file.txt echo something&lt;/code&gt; 來做&lt;/p&gt;&lt;p&gt;這個指令特別的地方在於 &lt;code&gt;echo&lt;/code&gt; 可以放在 &lt;code&gt;&amp;gt;&amp;gt; file.txt&lt;/code&gt; 之後，沒有那麼直覺&lt;/p&gt;&lt;p&gt;如果遇到有空格或是特殊符號，可以先用 &lt;code&gt;set&lt;/code&gt; 的方法建立內容&lt;/p&gt;&lt;p&gt;但是因為 &lt;code&gt;set&lt;/code&gt; 完可能會有雙引號 &lt;code&gt;&amp;quot;&lt;/code&gt; ，要解除得用 &lt;code&gt;%VAR:&amp;quot;=%&lt;/code&gt; 處理&lt;/p&gt;&lt;pre&gt;&lt;code&gt;REM 1. 有空格
set insertString1=&amp;quot;hello world&amp;quot;
set insertString1=%insertString1%
&amp;gt;&amp;gt; file1.txt echo insertString1

REM 2. 有特殊字符（例如 &amp;lt; 和 &amp;gt; ）使用 &amp;#94; 前置處理
set insertString2=&amp;quot;#include &amp;#94;&amp;lt;stdio&amp;#94;&amp;gt;&amp;quot;
set insertString2=%insertString2%
&amp;gt;&amp;gt; file2.txt echo insertString2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;刪除舊有內容，全新&amp;#95;append&amp;#95;(&amp;#95;相當於&amp;#95;write&amp;#95;)&quot;&gt;&lt;/a&gt;刪除舊有內容，全新 Append ( 相當於 Write )&lt;/h3&gt;&lt;p&gt;可以透過 &lt;code&gt;type&lt;/code&gt; 指令完成，例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;type src&amp;#95;file.txt &amp;gt; target&amp;#95;file.txt&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;在原有內容上&amp;#95;append&quot;&gt;&lt;/a&gt;在原有內容上 Append&lt;/h3&gt;&lt;p&gt;然而更多的是在原有內容上 Append&lt;/p&gt;&lt;p&gt;所以可以透過 &lt;code&gt;copy /b&lt;/code&gt; 以及 &lt;code&gt;+&lt;/code&gt; 的方式處理：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;copy /b append&amp;#95;file.txt+src&amp;#95;file.txt append&amp;#95;file.txt&lt;/code&gt;&lt;/pre&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 28 Dec 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2017-12-27-在Emacs中安靜地執行async-shell-command/
</guid>
<link>
http://lisp.rocks/posts-output/2017-12-27-在Emacs中安靜地執行async-shell-command/
</link>
<title>
Emacs 中安靜地執行 async-shell-command
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;安靜地在 Emacs 中執行 async-shell-command 有兩種方式：&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;1.&amp;#95;display-buffer-alist&quot;&gt;&lt;/a&gt;1. display-buffer-alist&lt;/h3&gt;&lt;p&gt;如果你想要對所有的 &lt;code&gt;async-shell-command&lt;/code&gt; 都安靜執行，可以透過：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;add-to-list 'display-buffer-alist
  '&amp;#40;&amp;quot;\\&amp;#42;Async Shell Command\\&amp;#42;.&amp;#42;&amp;quot; display-buffer-no-window&amp;#41;&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Spacemacs 中可以把上面兩行加入在 &lt;code&gt;dotspacemacs/user-config&lt;/code&gt; 裡面&lt;/p&gt;&lt;p&gt;缺點是所有的 async shell command 都會被安靜執行，有時候有些 async shell command 我們還是希望跳出視窗提醒&lt;/p&gt;&lt;p&gt;例如執行一些執行 local server 的 command ，不然再開一個可能會開新的 port 所以我推薦第二個方法&lt;/p&gt;&lt;p&gt;&lt;br&gt; &lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;2.&amp;#95;call-process-shell-command&quot;&gt;&lt;/a&gt;2. call-process-shell-command&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;call-process-shell-command&lt;/code&gt; 要留意指令後需要添加 &lt;code&gt;nil 0&lt;/code&gt; 參數：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;call-process-shell-command
    &amp;#40;async-shell-command 
        ... ;; 做你想做的事情 
       &amp;#41; nil 0&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這種方式對個別 async-shell-command 可以分別操作，但是缺點是他會問你要不要開新的 buffer&lt;/p&gt;&lt;p&gt;如果你是有透過 after-save-hook 之類的會高頻率地呼叫 asnc-shellc-ommand，那這個方法會很煩&lt;/p&gt;&lt;p&gt;可能就要選第一個方法&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;3.&amp;#95;shell-command&amp;#95;+&amp;#95;kill-buffer&quot;&gt;&lt;/a&gt;3. shell-command + kill-buffer&lt;/h3&gt;&lt;p&gt;如果你的 shell-command 跑起來很快就結束，又會高頻率地呼叫到的話&lt;/p&gt;&lt;p&gt;可以考慮使用 shell-command 而非 async 然後搭配 kill-buffer 來解決一堆 shell command buffer 的問題&lt;/p&gt;&lt;p&gt;也就是說，把 call-process-shell-command 中換成：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;call-process-shell-command
    &amp;#40;shell-command 
        ... ;; 做你想做的事情 
       &amp;#41;
    &amp;#40;kill-buffer &amp;quot;&amp;#42;Shell Command Output&amp;#42;&amp;quot; nil 0&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這樣即可，就留意可能會頓一下因為是在執行 shell-command&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 27 Dec 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2017-12-27-Emacs中處理Windows路徑轉換/
</guid>
<link>
http://lisp.rocks/posts-output/2017-12-27-Emacs中處理Windows路徑轉換/
</link>
<title>
Emacs 中處理 Windows 路徑轉換
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在 Windows 中使用 Emacs 時，處理路徑轉換很麻煩，因為你從各種函數中拿到的路徑可能會有：&lt;/p&gt;&lt;p&gt;1 . 像是 Linux 系統中的路徑，例如 &lt;code&gt;&amp;#126;/.spacemacs.d/&lt;/code&gt;&lt;/p&gt;&lt;p&gt;2 . 像是 Windows 系統中的路徑，例如 &lt;code&gt;c:\ \ Users \ \ myName&lt;/code&gt; ( Spacemacs 默認 c 是小寫 )&lt;/p&gt;&lt;p&gt;3 . 又或是兩者的混合版本，例如 &lt;code&gt;c:/Users/myName&lt;/code&gt; ，這種最麻煩&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;這樣在背景執行例如 &lt;code&gt;async-shell-command&lt;/code&gt; 就會很不方便&lt;/p&gt;&lt;p&gt;所以通常就得在外面再包一層把路徑換掉的函數，使用的方法可以用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;replace-regexp-in-string &amp;quot;\/&amp;quot; &amp;quot;\\\\&amp;quot; path&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或是：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;replace-regexp-in-string &amp;quot;/&amp;quot; &amp;#40;regexp-quote &amp;quot;\\&amp;quot;&amp;#41; path&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這樣就沒問題了，搭配 &lt;code&gt;projectile-project-root&lt;/code&gt; 就能輕鬆在跟目錄下執行 bat scripts ！&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 27 Dec 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/2017-12-26-回顧2017感謝篇/
</guid>
<link>
http://lisp.rocks/posts-output/2017-12-26-回顧2017感謝篇/
</link>
<title>
回顧2017 (感謝篇)
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;不知不覺又到了 2017 年尾，今年比起去年有了很大幅度的沉澱與成長&lt;/p&gt;&lt;p&gt;總結一句話的話，就是大概知道 &lt;strong&gt;「自己理想中的能力，與目前自己的大約差距」&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我就依序在各方面做一些紀錄，同時也感謝一些朋友與前輩（以 GitHub ID 稱呼）&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;今年年初過年期間的那 7-8 天，我把 &lt;a href='https://github.com/emacs-china/Spacemacs-rocks'&gt;子龍山人的 Spacemacs Rocks&lt;/a&gt; 全部看完&lt;/p&gt;&lt;p&gt;從那時候起開始使用 &lt;a href='https://github.com/syl20bnr/spacemacs'&gt;Spacemacs&lt;/a&gt; ，我已經記不得 2016 我怎麼還願意使用 Emacs&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;今年要總結成長最多的，就是在使用 Emacs 這件事上面！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;對我工作各方面都有 10x 效率 的提升&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;不過有兩個人對我使用 Emacs 有非常重要的影響，分別是：&lt;/p&gt;&lt;p&gt;1 . &lt;a href='https://github.com/emacs-tw/emacs-101-beginner-survival-guide'&gt;Emacs 101 新手求生指南&lt;/a&gt; 作者的 &lt;a href='https://github.com/kuanyui'&gt;kuanyui&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2 . &lt;a href='http://coldnew.github.io/COSCUP2013_org-mode/slide.html'&gt;Org-mode : Emacs 下的瑞士軍刀&lt;/a&gt; 作者的 &lt;a href='https://github.com/coldnew'&gt;coldnew&lt;/a&gt;&lt;/p&gt;&lt;p&gt;這兩位大大都出沒在 &lt;a href='https://telegram.me/joinchat/CJbTID9kpknioj9rYv6zgg'&gt;Telegram 的 EmacsTW 頻道&lt;/a&gt; ，很熱心的解答了我許多問題&lt;/p&gt;&lt;p&gt;在 2016 我看 Emacs 101 新手指南時，經常在頻道中問很白癡的問題&lt;/p&gt;&lt;p&gt;但是那時候 kuanyui 大大都很熱心的解答，那時候我使用 &lt;a href='https://github.com/overtone/emacs-live'&gt;Emacs-live&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;印象最深刻是我在 Emacs 101 新手指南第二、三章的時候&lt;/p&gt;&lt;p&gt;第一次使用 C-x i 指令，插入另一份文件到目前文件之中，我覺得這功能實在太酷了！&lt;/p&gt;&lt;p&gt;在此之前，我除了 Matlab 以及大學用過的 DevC++ 之外，沒有任何編輯器使用經驗&lt;/p&gt;&lt;p&gt;這大概是我 2016 能活下來的原因吧，儘管是回顧 2017 ，但還是想在提一下 2016 的往事&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;除此之外，就是 &lt;a href='https://clojure.tw'&gt;ClojureTW&lt;/a&gt; 的 &lt;a href='https://github.com/cataska'&gt;cataska&lt;/a&gt; 大大從 2015 到現在(2017)一直堅持辦活動！&lt;/p&gt;&lt;p&gt;讓我保持著對 LISP 持續學習沒有中斷。&lt;/p&gt;&lt;p&gt;更重要的是，今年 Emacs 在 COSCUP2017 上面有單獨的議程軌！&lt;/p&gt;&lt;p&gt;更更更重要的是，我居然有機會可以上去分享！&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;可能對於其他都是 IT 業界、軟硬體工程師的許多朋友來說，這好像不是什麼大事情&lt;/p&gt;&lt;p&gt;但對於我來說，是一個很大的自信心的鼓舞和肯定，我很高興前輩們願意給予機會QQ！&lt;/p&gt;&lt;p&gt;我從以前都不是特別會寫程式的人，每次在 Telegram 看到大家著一堆名詞，我都不了解&lt;/p&gt;&lt;p&gt;其實內心還是有點小沮喪啦&amp;#x2026; 但更多就是多聽多學&amp;#x2026;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;像是 caasi 大大每次都會在 &lt;a href='http://cschat.tw'&gt;cschat.tw&lt;/a&gt; 上面分享很多很不錯的資訊，都來不及讀&lt;/p&gt;&lt;p&gt;我當然知道我的本業和大家差距很大，但大家討論的東西我真的非常有興趣&lt;/p&gt;&lt;p&gt;這中間 coldnew 和 irc 上面的 letoh 大大不嫌棄給我許多很基礎的回覆，和指引都很感謝&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;比起去年， &lt;strong&gt;今年下半年在 Telegram 上面耍白癡的頻率開始降低&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;很重要的原因，就是我慢慢對「設計模式」、「重構」、「寫測試」有了更清楚的概念&lt;/p&gt;&lt;p&gt;可以大概知道怎麼樣去 Google 搜尋，找到答案&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;除此之外，在日常中無形對我有正面影響的更多朋友，我也都十分感謝&lt;/p&gt;&lt;p&gt;例如 Carl, Rudi, Jeffery, Albert, whitglint, Mioaski, Superbil, pertercmd, b4283 &amp;#x2026;&lt;/p&gt;&lt;p&gt;以及 Twitter 上面許多陌生推友，例如 M157q 以及他的 RSS 機器人&lt;/p&gt;&lt;p&gt;但是還是有許多要學習的地方，會繼續努力，前進 2018 ！&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 26 Dec 2017 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/0099-01-03-Blog-範例-jsPDF/
</guid>
<link>
http://lisp.rocks/posts-output/0099-01-03-Blog-範例-jsPDF/
</link>
<title>
Blog 範例 - jsPDF
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;嘗試使用 &lt;a href='https://github.com/MrRio/jsPDF'&gt;jsPDF&lt;/a&gt; 來在文章中可以自己產生客製化文件的功能&lt;/p&gt;&lt;p&gt;尤其是中文的部分，使用到 &lt;a href='https://github.com/sphilee/jsPDF-CustomFonts-support'&gt;jsPDF-CustomFonts-support&lt;/a&gt; 這個套件搭配 jsPDF 使用&lt;/p&gt;&lt;pre&gt;&lt;code&gt;var doc = new jsPDF&amp;#40;&amp;#41;;

// 設定字體為 王漢宗細圓體繁
doc.addFont&amp;#40;'wt006.ttf', 'HanWangYenLight', 'normal'&amp;#41;;
doc.setFont&amp;#40;'HanWangYenLight'&amp;#41;;

// 測試中文內容
doc.text&amp;#40;'&amp;#91;  &amp;#93; 1. 項目一', 10, 10&amp;#41;;
doc.text&amp;#40;'&amp;#91;  &amp;#93; 2. 項目二', 10, 20&amp;#41;;
doc.text&amp;#40;'&amp;#91;  &amp;#93; 3. 項目三', 10, 30&amp;#41;;
doc.text&amp;#40;'&amp;#91;  &amp;#93; 4. 項目四', 10, 40&amp;#41;;
doc.text&amp;#40;'&amp;#91;  &amp;#93; 5. 項目五', 10, 50&amp;#41;;

doc.save&amp;#40;'jspdf-from-lisp-rocks.pdf'&amp;#41;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.5/jspdf.debug.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../../fonts/jspdf.customfonts.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../../fonts/default_vfs.js&quot;&gt;&lt;/script&gt; &lt;div class=&quot;report&quot;&gt;&lt;/div&gt; &lt;button id=&quot;toPdfBtn&quot;&gt;Download PDF&lt;/button&gt; &lt;script src=&quot;../../data/jspdf-example.js&quot;&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 03 Jan 0099 00:00:00 +0800
</pubDate>
</item>
<item>
<guid>
http://lisp.rocks/posts-output/0099-01-02-Blog-範例-Flowchartjs/
</guid>
<link>
http://lisp.rocks/posts-output/0099-01-02-Blog-範例-Flowchartjs/
</link>
<title>
Blog 範例 - flowchart.js
</title>
<description>
&lt;h1&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2&gt;&lt;a name=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;本文章只是單純測試本部落格如何使用 &lt;a href='https://github.com/adrai/flowchart.js/'&gt;flowchart.js&lt;/a&gt;&lt;/p&gt;&lt;p&gt;方便未來在文章中插入使用&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;http://flowchart.js.org/raphael-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.8.0/flowchart.min.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;diagram&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt; &lt;div id=&quot;diagram2&quot;&gt;&lt;/div&gt; &lt;script src=&quot;../../data/flowchart-example.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Wed, 02 Jan 0099 00:00:00 +0800
</pubDate>
</item>
</channel>
</rss>
